<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Codle]]></title>
  <subtitle><![CDATA[无比芜杂的心绪]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://codle.net/"/>
  <updated>2016-08-18T14:28:45.871Z</updated>
  <id>http://codle.net/</id>
  
  <author>
    <name><![CDATA[Silver]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <link href="http://codle.net/2016/08/18/Observer/"/>
    <id>http://codle.net/2016/08/18/Observer/</id>
    <published>2016-08-18T14:22:30.000Z</published>
    <updated>2016-08-18T14:28:45.871Z</updated>
    <content type="html"><![CDATA[<h2 id="观察者模式">观察者模式</h2><p>观察者模式：在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象全都收到通知，并自动更新。</p>
<p>新学的OO原则：为交互对象之间的松耦合设计而努力。</p>
<h2 id="实例">实例</h2><p>假设我们现在为气象局工作，我们的传感器能获得当前的温度、湿度、气压，我们需要把数据汇总在三个公告板公布出去，公告板分别公布目前的状况、气象统计及简单的预报。</p>
<p>我们需要理清我们该干啥什么：</p>
<ul>
<li>用WeatherData表示传感器，可以通过get函数来获取温度等。</li>
<li>新的测量数据更新后，measurementsChanged()方法被调用。</li>
<li>需要实现三个布告板，当WeatherData有数据更新时，布告也要马上更新。</li>
<li>系统必须可拓展，比如增加删除布告板。</li>
</ul>
<p>根据上述内容，我们可以写出一个通常情况下的一种代码思路：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">WeatherData</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">measurementChanged</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//获取气温，湿度，气压</span></span><br><span class="line">        <span class="keyword">float</span> temp = getTemperature();</span><br><span class="line">        <span class="keyword">float</span> humidity = getHumidity();</span><br><span class="line">        <span class="keyword">float</span> pressure = getPressure();</span><br><span class="line">        <span class="comment">//更新布告板</span></span><br><span class="line">        currentConditionsDisplay.update(temp, humidity, pressure);</span><br><span class="line">        statisticsDisplay.update(temp, humidity, pressure);</span><br><span class="line">        forecastDisplay.update(temp, humidity, pressure);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以发现上述代码的不足，在更新布告板的时候是针对具体实现编程，一旦增加/减少布告板时就涉及到修改函数，缺乏弹性。而且每种布告板的更新方式也都是一样的，这样写出的代码就很冗余。</p>
<p>这里我们引入观察者模式来进行设计，观察者模式主要有两个部分：主题、观察者。双方的概念和报纸订阅比较相似，主题是出版商，观察者是订阅客户。当出版商更新报刊的时候，就把更新的内容分发给各个订阅商。这就是观察者模式的和谐运作了。</p>
<p>主题对象，可以向主题申请是否成为观察者，成为观察者后，主题每次更新，就会向观察者发送更新资料，每一个观察者也可以选择注销观察者身份，那么主题更新的时候，他就不再接收消息了。</p>
<p>我们改进的代码如下，注释还是比较详细的，偷懒只写了一个布告板:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//观察者接口</span></span><br><span class="line"><span class="keyword">class</span> Observer&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temp, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主题接口</span></span><br><span class="line"><span class="keyword">class</span> Subject&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer* o)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer* o)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//天气数据继承主题来分发数据</span></span><br><span class="line"><span class="keyword">class</span> WeatherData: <span class="keyword">public</span> Subject&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    WeatherData()&#123;&#125;</span><br><span class="line">    <span class="comment">//注册成为观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer* o)</span></span>&#123;</span><br><span class="line">        observers.push_back(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//删除观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer* o)</span></span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;Observer*&gt;::iterator it = observers.begin();</span><br><span class="line">        <span class="keyword">for</span>(; it != observers.end(); it++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(*it == o)&#123;</span><br><span class="line">                observers.erase(it);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向观察者分发新的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; observers.size(); i++)&#123;</span><br><span class="line">            observers[i]-&gt;update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//数据更新触发</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span></span>&#123;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取新的数据，实际应用中应该是调用外部的api</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>-&gt;humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>-&gt;pressure = pressure;</span><br><span class="line">        measurementsChanged();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;Observer*&gt; observers;</span><br><span class="line">    <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">float</span> humidity;</span><br><span class="line">    <span class="keyword">float</span> pressure;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发布板显示数据接口</span></span><br><span class="line"><span class="keyword">class</span> DisplayElement&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当前状况发布板，继承观察者和显示接口</span></span><br><span class="line"><span class="keyword">class</span> CurrentConditionsDisplay: <span class="keyword">public</span> Observer, DisplayElement&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//向天气数据注册成为观察者</span></span><br><span class="line">    CurrentConditionsDisplay(Subject* weatherData)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weatherData = weatherData;</span><br><span class="line">        weatherData-&gt;registerObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新发布板内数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity, <span class="keyword">float</span> pressure)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>-&gt;humidity = humidity;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//显示数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Current Conditios:"</span> &lt;&lt; temperature &lt;&lt; <span class="string">"F degrees and "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; humidity &lt;&lt; <span class="string">"% humidity"</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">float</span> temperature;</span><br><span class="line">    <span class="keyword">float</span> humidity;</span><br><span class="line">    Subject* weatherData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    WeatherData* weatherData = <span class="keyword">new</span> WeatherData();</span><br><span class="line"></span><br><span class="line">    CurrentConditionsDisplay* currentDisplay = <span class="keyword">new</span> CurrentConditionsDisplay(weatherData);</span><br><span class="line"></span><br><span class="line">    weatherData-&gt;setMeasurements(<span class="number">80</span>, <span class="number">65</span>, <span class="number">30.4f</span>);</span><br><span class="line">    weatherData-&gt;setMeasurements(<span class="number">82</span>, <span class="number">70</span>, <span class="number">29.2f</span>);</span><br><span class="line">    weatherData-&gt;setMeasurements(<span class="number">78</span>, <span class="number">90</span>, <span class="number">29.2f</span>);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="观察者模式">观察者模式</h2><p>观察者模式：在对象之间定义一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象全都收到通知，并自动更新。</p>
<p>新学的OO原则：为交互对象之间的松耦合设计而努力。</p>
<h2 id="实例">实例</h2><]]>
    </summary>
    
      <category term="设计模式" scheme="http://codle.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[设计模式：策略模式]]></title>
    <link href="http://codle.net/2016/08/10/strategy-pattern/"/>
    <id>http://codle.net/2016/08/10/strategy-pattern/</id>
    <published>2016-08-09T17:08:45.000Z</published>
    <updated>2016-08-09T17:14:02.905Z</updated>
    <content type="html"><![CDATA[<h2 id="策略模式">策略模式</h2><p>定义：定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>
<p>算法族：通常情况下，我们称呼对象的功能为<strong>一组行为</strong>,这里我们用<strong>一族算法</strong>的描述来替换刚刚的称呼，其实质就是我们将对象的行为抽象出来，创造一个<strong>行为类</strong>。</p>
<p>下面讲述设计时候的三个原则:</p>
<ol>
<li>找出应用中可能需要的变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。</li>
<li>针对接口编程，而不是针对实现编程。</li>
<li>多用组合，少用继承。</li>
</ol>
<h2 id="实现实例">实现实例</h2><p>下面给出一个运用策略模式来设计的一个实例(书上用的Java，这里改为了C++):<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//飞行行为基类，纯虚函数并没有实现</span></span><br><span class="line"><span class="keyword">class</span> FlyBehavior&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//叫声行为基类</span></span><br><span class="line"><span class="keyword">class</span> QuackBehavior&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有翅膀的飞行行为，继承了飞行基类</span></span><br><span class="line"><span class="keyword">class</span> FlyWithWings: <span class="keyword">public</span> FlyBehavior&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Duck is flying"</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没翅膀的飞行行为</span></span><br><span class="line"><span class="keyword">class</span> FlyNoWay: <span class="keyword">public</span> FlyBehavior&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Cannot fly"</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鸭子叫声行为，继承了叫声行为基类</span></span><br><span class="line"><span class="keyword">class</span> Quack: <span class="keyword">public</span> QuackBehavior&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"GAGAGAGA..."</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//橡皮鸭子的叫声行为</span></span><br><span class="line"><span class="keyword">class</span> Squeak: <span class="keyword">public</span> QuackBehavior&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Zzzzzzzz..."</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无法叫出声音的叫声行为</span></span><br><span class="line"><span class="keyword">class</span> MuteQuack: <span class="keyword">public</span> QuackBehavior&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"..."</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鸭子基类，创建了飞行、叫声行为指针</span></span><br><span class="line"><span class="keyword">class</span> Duck&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	QuackBehavior* quackBehavior;</span><br><span class="line">	FlyBehavior* flyBehavior;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">performFly</span><span class="params">()</span></span>&#123;</span><br><span class="line">		flyBehavior-&gt;fly();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">performQuack</span><span class="params">()</span></span>&#123;</span><br><span class="line">		quackBehavior-&gt;quack();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建绿头鸭类，继承自鸭子类，在构造函数中，创建了飞行、叫声实例</span></span><br><span class="line"><span class="keyword">class</span> MallardDuck: <span class="keyword">public</span> Duck&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MallardDuck()&#123;</span><br><span class="line">		quackBehavior = <span class="keyword">new</span> Quack();</span><br><span class="line">		flyBehavior = <span class="keyword">new</span> FlyWithWings();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"I have a green head."</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	MallardDuck m;</span><br><span class="line">	m.display();</span><br><span class="line">	m.performQuack();</span><br><span class="line">	m.performFly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="设计分析">设计分析</h2><p>首先，我们有不同的鸭子（绿头鸭，红头鸭，橡皮鸭）他们的外形各不相同，行为也不一样，绿头鸭和红头鸭都能飞，橡皮鸭却不能飞，叫声也同理不太一样。</p>
<p>一开始我们可能会这样设计，将飞行，叫声设置成鸭子基类的虚函数，然后再在具体鸭子类中去实现一次。这样设计的问题在于，每出现一个不同类别的鸭子，我们就需要去重新写飞行、叫声函数（可能我们还有更多的行为）。</p>
<p>因此，我们引入行为类，不同的鸭子他们的行为是不同的，将不同的地方抽离出来形成一个类，这样我们在构建一个具体类的时候，只用将基类和相应的行为类组合起来就能实现了。并且，我们在行为类中改变代码也不会影响到我们的基类。</p>
<p>实例中Duck基类包含了两个函数，表示鸭子有两个行为叫和飞，因为我们不知道鸭子具体的叫和飞，我们这里就用父类指针来进行相应操作。这里重新讲一下C++中的一些概念：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">canRun</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Animal Run"</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> Dog: <span class="keyword">public</span> Animal&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">canRun</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"Dog Run"</span> &lt;&lt;endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Animal* animal = <span class="keyword">new</span> Dog();</span><br><span class="line">animal.canRun();</span><br></pre></td></tr></table></figure></p>
<p>父类指针可以使用子类继承自父类的虚函数，这时候实际执行的是子类的重新写的虚函数Dog::canRun()。所以利用这个原则，我们就可以编写出不会变化的基类了。</p>
<p>在具体类的实现中，我们在构造函数中使用了具体实现，这一点和我们本节的设计模式其实并不太切合，这里我们只能这样做，在后面更多的设计模式中可以学到更多的工具来修正这一点。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="策略模式">策略模式</h2><p>定义：定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>
<p>算法族：通常情况下，我们称呼对象的功能为<strong>一组行为</strong>,这里我们用<strong>一族]]>
    </summary>
    
      <category term="设计模式" scheme="http://codle.net/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[日常的C++编译软件]]></title>
    <link href="http://codle.net/2016/08/08/cpp-writting/"/>
    <id>http://codle.net/2016/08/08/cpp-writting/</id>
    <published>2016-08-08T07:17:08.000Z</published>
    <updated>2016-08-08T07:18:35.246Z</updated>
    <content type="html"><![CDATA[<p>我C++主要用于刷算法题目，因此对于IDE的需求不是特别大，刷几道题目就需要打开Visual Studio 2015的话实在不是很划算，毕竟电脑还不是太好，打开也有点略卡。如果是工程性项目还是首推VS2015。</p>
<h2 id="Bash_For_Windows（+Vim）">Bash For Windows（+Vim）</h2><p>在最新版的Windows10操作系统中，开发者模式下可以使用Ubuntu子系统，这让我们可以在不放弃Windows系统的情况下进行Linux编程，占用的内存远低于虚拟机。</p>
<h3 id="安装Bash_on_Windows">安装Bash on Windows</h3><ol>
<li>首先需要确定Windwos10版本为1607以上，若低于该版本请使用更新。</li>
<li>打开设置-更新和安全-针对开发者功能，勾选开发人员模式。</li>
<li>控制面板-程序-启用或关闭Windows功能，勾上<strong>适用于Linux的Winodws子系统(beta)</strong>。</li>
<li>打开命令提示符，输入<strong>C:\windows\system32\bash.exe</strong>（管理员模式下直接输入<strong>bash</strong>即可）。</li>
<li>根据提示就开始下载了，安装后需要设置账号和密码，<strong>密码输入时是不可见的</strong>。</li>
<li>完成后，以后直接在命令提示符里输入bash，即可进入bash模式，和Ubuntu终端完全一样的体验。</li>
</ol>
<h3 id="美化终端">美化终端</h3><p>考虑到微软的CMD窗口实在太丑，我们可以稍微美化一下，这里推荐cmder这个软件，官网地址：<a href="http://cmder.net/" target="_blank" rel="external">点我</a>，提供了精简版(mini，只有基础功能)和全功能版（full，带了git功能），可以根据自己的需要下载。<br>为了避免每次运行都需要手动输入Bash来进入Bash模式，我们可以设置启动命令来帮助我们这一操作，点击cmder左上角图标-Settings-Startup，选择<strong>Command line</strong>输入下面这条命令:<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%windir%\system32\<span class="keyword">bash.exe </span>-cur_console:<span class="literal">p1</span></span><br></pre></td></tr></table></figure></p>
<p>这样启动后就能直接进入bash模式，设置里面还有多种配色和字体选择，可以根据需要自己设置。</p>
<h3 id="应用安装及使用">应用安装及使用</h3><p>输入<strong>cd</strong>可以进入根目录，默认的根目录在<strong>C:\Users\userName\AppData\Local\lxss</strong>下面。想要跳转到电脑的其他位置的时候需要在盘符前面加上<strong>/mnt</strong>，比如去D盘的cpp文件夹则需要输入cd /mnt/d/cpp。<br>g++，vim这些默认是已经安装好了的，若没有安装可以使用下面的命令安装:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">%gcc安装</span><br><span class="line">sudo apt-get <span class="operator"><span class="keyword">install</span> gcc </span><br><span class="line">%<span class="keyword">g</span>++安装</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> <span class="keyword">g</span>++</span><br><span class="line">%vim安装</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> vim</span></span><br></pre></td></tr></table></figure></p>
<p>跳转至工作目录，使用<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">vim</span> <span class="tag">hello</span><span class="class">.cpp</span></span><br></pre></td></tr></table></figure></p>
<p>创建一个hello.cpp文件，进入vim编辑模式。vim使用教程可以参看:<a href="http://blog.jobbole.com/18339/" target="_blank" rel="external">简明Vim练级攻略</a>，后面有空我在自己补一篇吧。<br>保存退出后，我们想要编译这个cpp文件，使用下面的命令:<br><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%编译成可执行文件hello</span></span><br><span class="line"><span class="function_or_atom">g</span>++ <span class="function_or_atom">hello</span>.<span class="function_or_atom">cpp</span> -<span class="function_or_atom">o</span> <span class="function_or_atom">hello</span></span><br><span class="line"><span class="comment">%运行可执行文件</span></span><br><span class="line">./<span class="function_or_atom">hello</span></span><br></pre></td></tr></table></figure></p>
<p>当然我们也可以在vim中设置按F5编译，大家可以参考网上的资料。</p>
<h2 id="Visual_Studio_Code_+_MinGW">Visual Studio Code + MinGW</h2><p>Visual Studio Code是微软全新推出的一款编辑器（仅仅只有编辑器功能哦），美观的界面，小巧的容量，高性能的打开速度从出生就获得了非常高关注度。在最新版中已经允许了插件拓展，我们可以通过插件拓展来实现调试运行功能。</p>
<h2 id="安装">安装</h2><p>打开网站<a href="https://code.visualstudio.com" target="_blank" rel="external">Visual Studio Code</a>官网，点击Download for Windows即可下载。软件90%已实现中文汉化（微软真是业界良心啊）。</p>
<p>安装完成后运行，点击左侧第五个按钮，在搜索栏中输入C++，选择第一个由微软官方出品的C/C++插件安装，安装时间可能会比较久。</p>
<p>在下载插件的时候，我们可以先去安装MinGW，因为VSCode只是一个编辑器，因此我们需要给电脑安装MinGW，然后通过插件来调用MinGW来进行调试运行（也可以选择Cygwin）。</p>
<p>进入<a href="http://mingw.org/" target="_blank" rel="external">MinGW官网</a>，右上角位置点击Download Installer，下载MinGW下载器。下载完成后运行。这是一个下载器，我们需要选择要下载的包，在Basic Setup中勾上mingw32-gcc-g++，在All Packgaes-MinGW Base System-MinGW Source Level Debugger中全部勾上。然后点击左上角Installation-Apply Changes进行安装。完成后在系统的环境变量中添加MinGW的bin文件夹位置(控制面板\系统和安全\系统-高级系统设置-环境变量-系统变量双击Path添加新的一行，比如我的就是添加E:\MinGW\bin)可以打开命令提示符输入<strong>gcc -v</strong>来确定是否安装成功。</p>
<h2 id="配置插件">配置插件</h2><p>先随便写一个cpp文件，然后点击左侧第四个按钮，点击设置齿轮，在setting.json中用下面代码块替换相应部分:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">            <span class="string">"name"</span>: <span class="string">"C++ Launch"</span>,</span><br><span class="line">            <span class="string">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="string">"targetArchitecture"</span>: <span class="string">"x64"</span>,</span><br><span class="line">            <span class="string">"program"</span>: <span class="string">"<span class="variable">$&#123;file&#125;</span>.exe"</span>,</span><br><span class="line">            <span class="string">"args"</span>: [],</span><br><span class="line">            <span class="string">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="string">"cwd"</span>: <span class="string">"<span class="variable">$&#123;workspaceRoot&#125;</span>"</span>,</span><br><span class="line">            <span class="string">"miDebuggerPath"</span>:<span class="string">"e:\\MinGW\\bin\\gdb.exe"</span>,</span><br><span class="line">            <span class="string">"environment"</span>: [],</span><br><span class="line">            <span class="string">"externalConsole"</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="string">"preLaunchTask"</span>: <span class="string">"g++"</span>,</span><br><span class="line">            <span class="string">"linux"</span>: &#123;</span><br><span class="line">                <span class="string">"MIMode"</span>: <span class="string">"gdb"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"osx"</span>: &#123;</span><br><span class="line">                <span class="string">"MIMode"</span>: <span class="string">"lldb"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"windows"</span>: &#123;</span><br><span class="line">                <span class="string">"MIMode"</span>: <span class="string">"gdb"</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br></pre></td></tr></table></figure></p>
<p>注意修改下自己的MinGW目录。然后切回cpp文件点击绿色运行按钮，这时候会弹出一个选择窗口，随便选择一个，然后用下面的内容替换:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,</span><br><span class="line">    <span class="string">"command"</span>: <span class="string">"g++"</span>,</span><br><span class="line">    <span class="string">"args"</span>: [<span class="string">"-g"</span>,<span class="string">"$&#123;file&#125;"</span>,<span class="string">"-static"</span>,<span class="string">"-o"</span>,<span class="string">"$&#123;file&#125;.exe"</span>],</span><br><span class="line">    <span class="string">"problemMatcher"</span>: &#123;</span><br><span class="line">        <span class="string">"owner"</span>: <span class="string">"cpp"</span>,</span><br><span class="line">        <span class="string">"fileLocation"</span>: [<span class="string">"relative"</span>, <span class="string">"$&#123;workspaceRoot&#125;"</span>],</span><br><span class="line">        <span class="string">"pattern"</span>: &#123;</span><br><span class="line">            <span class="string">"regexp"</span>: <span class="string">"^(.*):(\\d+):(\\d+):\\s+(warning|error):\\s+(.*)$"</span>,</span><br><span class="line">            <span class="string">"file"</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">"line"</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="string">"column"</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="string">"severity"</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="string">"message"</span>: <span class="number">5</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>“-static”参数可以不写，如果系统变量中含有多个版本不同的编译库就请一定带上。完成后cpp文件就能使用F5运行了，也可以设置断点等等调试工作。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我C++主要用于刷算法题目，因此对于IDE的需求不是特别大，刷几道题目就需要打开Visual Studio 2015的话实在不是很划算，毕竟电脑还不是太好，打开也有点略卡。如果是工程性项目还是首推VS2015。</p>
<h2 id="Bash_For_Windows（+V]]>
    </summary>
    
      <category term="软件" scheme="http://codle.net/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习日志：Logistic 回归]]></title>
    <link href="http://codle.net/2016/08/02/logistic-regression/"/>
    <id>http://codle.net/2016/08/02/logistic-regression/</id>
    <published>2016-08-02T12:27:46.000Z</published>
    <updated>2016-08-07T09:16:04.399Z</updated>
    <content type="html"><![CDATA[<h2 id="Logistic回归">Logistic回归</h2><p>Logistic回归(《统计学习方法》中译为逻辑斯谛回归），虽然也是回归模型，但是与线性回归模型不同，Logistic回归通过训练数据集来对数据集建立边界用于数据分类，因此主要用于分类器。<br>对于Logistic回归，我们的预测函数不再是根据特征来输出一个数据值了，而是分类的类别，比如结果类别只有两个，那么我们通过预测函数的输出值就应该是0,1。具有这种性质的函数被称为阶跃函数，瞬间阶跃可能比较难处理，我们引入另一个具有类似性质的函数Sigmoid函数。Sigmoid函数的具体计算公式如下：<br>$$\sigma(z)=\frac1{1+e^{-z}}$$<br>当$z=0$时，$\sigma(z)=0.5$，当$z$值增大时，$\sigma(z)$值逼近于$1$，随着$z$减少时，$\sigma(z)$值逼近0。如果横坐标刻度足够大，那么Sigmoid函数看起来就像阶跃函数。</p>
<h2 id="Logistic回归模型">Logistic回归模型</h2><h3 id="模型">模型</h3><p>二项Logistic回归模型是一种分类模型，由条件概率分布$P(Y|X)$表示，形式为参数化的Logistic分布。条件概率为：<br>$$P(Y=1|x)=\frac1{1+e^{-w\cdot x}} \\P(Y=0|x)=\frac{e^{-w\cdot x}}{1+e^{-w\cdot x}}$$<br>$x\in R^n$为输入特征值，$Y\in {0,1}$是输出值，$w\in R^n$是权值参数。对于给定的输入实例$x$，Logistic回归通过比较两个条件概率值的大小来分配实例$x$到概率较大的那一类中。</p>
<h3 id="特点">特点</h3><p>一个事件的几率(odds,the odds of experiencing an event)是指该事件发生的概率与该事件不发生的概率的比值。如果事件发生的概率为$p$，那么该事件的几率为$\frac{p}{1-p}$，该事件的对数几率（log odds）是<br>$$logit(p)=log\frac{p}{1-p}$$<br>那么针对Logistic回归，对数几率就为：<br>$$log\frac{P(Y=1|x)}{1-P(Y=1|x)}=w\cdot x$$<br>这就表示在Logistic回归模型中，输出$Y=1$的对数几率是输入$x$的线性函数。</p>
<h2 id="模型参数估计">模型参数估计</h2><p>Logistic回归模型学习时，对于给定的训练集$T = \{(x_1,y_1),(x_2,y_2),\cdots,(x_n,y_n)\}$，可以采用极大似然估计法来估计模型参数。<br>设：$ P(Y=1|x)=\pi(x),P(Y=0|x)=1-\pi(x)$<br>似然函数为：<br>$$\prod_{i=1}^n[\pi(x_i)]^{y_i}[1-\pi(x_i)]^{1-y_i}$$<br>对数似然函数为：<br>$$L(w)=\sum_{i=1}^n[y_ilog(\pi(x_i))+(1-y_i)log(1-\pi(x_i))]$$<br>对$L(w)$求取极大值，就能得到$w$的极大似然估计。用大学《概率统计》所学的就是求<br>$$\frac{\partial L(w)}{\partial w}=0$$<br>时的$w$的值就是$w$的极大似然估计$\hat w$<br>由于方程比较复杂无法直接进行求偏导运算，因此考虑迭代法来求取近似值，一般使用梯度下降法和拟牛顿法。</p>
<h2 id="Logistic回归实战（Python）">Logistic回归实战（Python）</h2><p>首先我们从文本中读取出数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">()</span>:</span></span><br><span class="line">    X = []; y = []</span><br><span class="line">    fr = open(<span class="string">'./Tests/ex2data2.txt'</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        line_arr = line.strip().split(<span class="string">','</span>)</span><br><span class="line">        X.append([<span class="number">1.0</span>, float(line_arr[<span class="number">0</span>]), float(line_arr[<span class="number">1</span>])])</span><br><span class="line">        y.append(float(line_arr[-<span class="number">1</span>]))</span><br><span class="line">    fr.close()</span><br><span class="line">    X = array(X)</span><br><span class="line">    y = array(y)</span><br><span class="line">    <span class="keyword">return</span> X, y</span><br></pre></td></tr></table></figure></p>
<p>我们使用matplotlab.pyplot库来打印图形，我们先把刚刚的数据图形化打印出来<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_data</span><span class="params">(X, y)</span>:</span></span><br><span class="line">    m = shape(X)[<span class="number">0</span>]</span><br><span class="line">    xcord1 = []; ycord1 = []</span><br><span class="line">    xcord2 = []; ycord2 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">if</span> int(y[i]) == <span class="number">1</span>:</span><br><span class="line">            xcord1.append(X[i, <span class="number">1</span>])</span><br><span class="line">            ycord1.append(X[i, <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            xcord2.append(X[i, <span class="number">1</span>])</span><br><span class="line">            ycord2.append(X[i, <span class="number">2</span>])</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax.scatter(xcord1, ycord1, s=<span class="number">30</span>, c=<span class="string">'red'</span>, marker=<span class="string">'s'</span>)</span><br><span class="line">    ax.scatter(xcord2, ycord2, s=<span class="number">30</span>, c=<span class="string">'green'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'X1'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'X2'</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们得到下面这张图:<br><img src="http://codle.net/imgs/machine-learning/03-01.png" alt=""></p>
<p>Sigmoid函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(inx)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1</span>+exp(-inx))</span><br></pre></td></tr></table></figure></p>
<p>本来我们只有两个特征量$x_1，x_2$，但仅仅两个特征量只能拟合出一条直线，因此我们需要使用特征量的不同幂来拓展特征量，比如$x_1x_2,x_1^2,x_2^2,x_1^2x_2\cdots$，可以写成循环形式，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map_feature</span><span class="params">(x1, x2)</span>:</span></span><br><span class="line">    out = ones((shape(x1)[<span class="number">0</span>], <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i+<span class="number">1</span>):</span><br><span class="line">            temp = (x1**(i-j))*(x2**j)</span><br><span class="line">            out = column_stack((out, reshape(temp, len(temp))))</span><br><span class="line">    <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure></p>
<p>一个简单的梯度上升算法，没有正则化，但对这次的题目影响不大，梯度算法可以参考上一篇文章:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grad_ascent</span><span class="params">(data_mat_in, class_labels)</span>:</span></span><br><span class="line">    data_mat = mat(data_mat_in)</span><br><span class="line">    label_mat = mat(class_labels).transpose()</span><br><span class="line">    m, n = shape(data_mat)</span><br><span class="line">    alpha = <span class="number">0.001</span></span><br><span class="line">    max_cycle = <span class="number">3000</span></span><br><span class="line">    theta = ones([n, <span class="number">1</span>])</span><br><span class="line">    theta = mat(theta)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(max_cycle):</span><br><span class="line">        h = sigmoid(data_mat*theta)</span><br><span class="line">        error = (label_mat - h)</span><br><span class="line">        theta += alpha*data_mat.transpose()*error</span><br><span class="line">    <span class="keyword">return</span> theta</span><br></pre></td></tr></table></figure></p>
<p>我们将拟合出来的权值$w$做成函数曲线打印出来:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_fit</span><span class="params">(theta, X, y)</span>:</span></span><br><span class="line">    plot_data(X[:, <span class="number">0</span>:<span class="number">3</span>], y)</span><br><span class="line">    u = linspace(-<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">50</span>)</span><br><span class="line">    v = linspace(-<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">50</span>)</span><br><span class="line">    z = zeros((len(u), len(v)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(u)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(v)):</span><br><span class="line">            z[i, j] = mat(map_feature(array([u[i]]), array([u[j]])))*mat(theta)</span><br><span class="line">    z = z.transpose()</span><br><span class="line">    plt.contour(u, v, z, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>打印出来的效果如下图所示，可以看出曲线基本拟合了我们的训练数据集<br><img src="http://codle.net/imgs/machine-learning/03-02.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Logistic回归">Logistic回归</h2><p>Logistic回归(《统计学习方法》中译为逻辑斯谛回归），虽然也是回归模型，但是与线性回归模型不同，Logistic回归通过训练数据集来对数据集建立边界用于数据分类，因此主要用于分类器。<br>对于Lo]]>
    </summary>
    
      <category term="机器学习" scheme="http://codle.net/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习日志：线性回归]]></title>
    <link href="http://codle.net/2016/07/14/linear-regression/"/>
    <id>http://codle.net/2016/07/14/linear-regression/</id>
    <published>2016-07-14T11:24:48.000Z</published>
    <updated>2016-07-19T08:44:33.528Z</updated>
    <content type="html"><![CDATA[<h2 id="线性回归模型">线性回归模型</h2><p>线性回归模型属于监督学习的一种，给定训练数据集，通过’学习’找出一个较精确的函数$h$来描述输入X和输出Y之间的关系，进而完成’预测’的功能，比如房屋价格预测。<br>对于一个输入变量x和一个输出变量y，可以用这样一个函数$h_\theta(x) = \theta_0 + \theta_1x$来表达，我们可以很容易地得出一个更一般的表达（即并不一定只有一个输入变量x的情况）:<br>$$h_\theta(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + \theta_3x_3 + \cdots$$<br>我们将单个输入量的情况叫做一元线性回归，多个输入量的叫做多元线性回归。</p>
<h2 id="$\theta$参数求解">$\theta$参数求解</h2><p>对于线性回归模型，我们的最终目的是要得到一个较精确的$h_\theta(x)$函数来表示输入和输出的关系，因此，我们的工作目的就是算出合适的$\theta$参数，来使得我们的函数曲线与数据点集尽可能地耦合。</p>
<h3 id="梯度下降法">梯度下降法</h3><h4 id="概念">概念</h4><p>这里使用梯度下降(Gradient Descent)的方法来求解参数$\theta$。梯度下降是求解无约束最优化问题的一种最常用的方法。从直观上理解就好似我们站在山顶(初始点)，希望能最快的地走到山脚(最优解)，那么我们通过每次向四周找寻一个方向（最陡的方向）走一步，找一个方向，再走一步，这样一次又一次地走到山脚。通过这样的描述很容易看出梯度下降的使用问题：可能会陷于局部最优解而无法获得全局最优解(就是说掉坑里了,HOHO)，但是对于凸函数是能求得最优解的。<br>从专业术语来描述梯度下降法就是:选取使得初始值$x^{(0)}$，不断迭代，更新$x$的值，进行目标函数的极小化，直到收敛。由于负梯度方向是使函数值下降最快的方向，在迭代的每一步，以负梯度方向更新$x$的值，从而达到减少函数值的目的。</p>
<h4 id="算法步骤">算法步骤</h4><p>在这里我们引入代价函数$J(\theta)$的概念，直观上理解可以当成从山顶到山底所需要的消耗，我们希望这个消耗尽可能地小。因此线性回归模型就是通过学习函数$h(x)$使得代价函数$J(\theta)$最小。<br>算法的步骤大致就是这样的:</p>
<ul>
<li>计算代价函数值$J(\theta)$</li>
<li>迭代更新$\theta$</li>
</ul>
<p>重复上面的操作，直到$J(\theta)$收敛的时候(可以采用画图的方法)，我们也就得到了一个较为准确的$\theta$参数。</p>
<h4 id="代价函数$J(\theta)$">代价函数$J(\theta)$</h4><p>在线性回归中，我们使用最小二乘法的方法来当作我们的代价函数$J(\theta)$。<br>$$J(\theta) = \frac1{2m}\sum_{i=1}^m(h_\theta(x^{(i)}) - y^{(i)})^2$$<br>注：<br>$$h_\theta(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + \theta_3x_3 + \cdots = \begin{bmatrix}1 &amp; x_1 &amp; x_2 \cdots &amp; x_n\end{bmatrix} \begin{bmatrix}\theta_0 \\ \theta_1 \\ \vdots \\ \theta_n\end{bmatrix}$$</p>
<h4 id="更新参数$\theta$">更新参数$\theta$</h4><p>下降最快的方向是负梯度的方向，很容易写出:<br>$$\theta := \theta - \nabla J(\theta)$$<br>注意这里的$\theta = \begin{bmatrix}\theta_0&amp;\theta_1&amp;\theta_2&amp;\cdots&amp;\theta_n\end{bmatrix}^T$，这个公式涉及到偏导数，在进行具体实现时，我们通常转化为下面这个公式进行求解:<br>$$\theta_j := \theta_j - \alpha\frac1{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}$$<br>这个分别对每个$\theta$进行求解，但是在计算的时候需要注意一定<strong>要用原始的$\theta$算完所有的$\theta$后再进行参数更新！</strong></p>
<p>在实战中，对于$x = \begin{bmatrix} \cdots &amp; x^{(0)} &amp; \cdots \\ \cdots &amp; x^{(1)}&amp; \cdots \\ \cdots &amp;\cdots&amp;\cdots \\ \cdots &amp; x^{(n)}&amp;\cdots \end{bmatrix} y = \begin{bmatrix}y^{(0)}\\y^{(1)}\\ \vdots \\ x^{(n)}\end{bmatrix} \theta = \begin{bmatrix} \theta_0\\ \theta_1 \\ \vdots \\ \theta_n \end{bmatrix}$,这个公式也可以写成：<br>$$\theta := \theta - \alpha\frac1{m}(x^T(x\theta-y))$$</p>
<h4 id="特征正则化">特征正则化</h4><p>这一步实际应该在所有步骤之前，主要用于将特征量$x$缩放至一个相对合适的大小（一般在$\pm2$之间），防止过拟合等状况出现。举个例子，也就说你一个特征量是3000左右，另一个却在0.2左右，这样算法在计算的时候很容易出现之字形下降，耗费额外的迭代次数却很难找到合适的参数。<br>常用的正则化方法为:<br>$$ x’ = \frac{x - \overline{x}}{\delta}$$<br>$\overline{x}$是特征平均值；$\delta$是特征标准差，也可以用$max-min$替代。</p>
<h3 id="正规方程法（Normal_Equation）">正规方程法（Normal Equation）</h3><p>这里在讲一种用于解决线性回归问题的方法，叫做正规方程法。用解方程的形式来进行求解参数$\theta$，公式非常简明:<br>$$\theta = (X^TX)^{-1}X^T\vec{y}$$<br>这个方程看似简单，但是缺点却很明显：涉及对矩阵求逆。矩阵逆运算的时间复杂度为$O(n^3)$，当特征很多的时候运行效率会非常缓慢。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="线性回归模型">线性回归模型</h2><p>线性回归模型属于监督学习的一种，给定训练数据集，通过’学习’找出一个较精确的函数$h$来描述输入X和输出Y之间的关系，进而完成’预测’的功能，比如房屋价格预测。<br>对于一个输入变量x和一个输出变量y，可以用这样一个函]]>
    </summary>
    
      <category term="机器学习" scheme="http://codle.net/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="线性回归" scheme="http://codle.net/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习日志：介绍]]></title>
    <link href="http://codle.net/2016/03/31/machine-learning-introduction/"/>
    <id>http://codle.net/2016/03/31/machine-learning-introduction/</id>
    <published>2016-03-31T02:11:15.000Z</published>
    <updated>2016-07-05T08:55:21.332Z</updated>
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近开始学习C站上的NG的机器学习课程，会把视频中的内容写成笔记方便查阅，待学完后会将全部的笔记整理成PDF。</p>
<h1 id="监督学习（Supervised_Learning）">监督学习（Supervised Learning）</h1><h2 id="示例1:预测房价">示例1:预测房价</h2><p>为了预测房价，某同学收集了某地区的房价数据集（如图），假设你朋友有栋750尺的房子，想知道房子在什么价格好卖掉。</p>
<p><img src="/imgs/machine-learning/01-01.png" alt=""></p>
<p>学习算法可以提供一些用于估计房子价格的方法，比如使用直线函数，或者使用平方函数等等方法来进行拟合。下图给出了两种不同函数拟合后估计的结果。</p>
<p><img src="/imgs/machine-learning/01-02.png" alt=""></p>
<h2 id="定义:监督学习">定义:监督学习</h2><p>监督学习，意在给定一个算法，需要部分数据集已有正确答案。比如给定房价数据集，对于里面的每个数据，算法都知道对应的正确房价，即房子的实际卖出价格。算法的结果就是算出更多正确的价格，比如那个新房子，你朋友想卖的那个。</p>
<h2 id="定义:回归问题">定义:回归问题</h2><p>回归问题属于监督学习，意在预测一个连续值的输出，比如价格，意味着要预测这类连续值属性的种类。</p>
<h2 id="示例2:肿瘤问题">示例2:肿瘤问题</h2><p>预测胸部肿瘤是良性还是恶性，下面是一个已知数据集，横轴代表肿瘤大小，纵轴用1表示恶性，0表示良性。</p>
<p><img src="/imgs/machine-learning/01-03.png" alt=""></p>
<p>现在假设一个人得了肿瘤，其大小是图中的品红箭头位置，现在希望能估算出肿瘤是良性还是恶性的概率。</p>
<h2 id="定义:分类问题">定义:分类问题</h2><p>分类问题被用于预测离散值的输出，比如肿瘤问题，其结果要么为良性，要么为恶性，这是一个离散的数据。数据集需要有一定的特征量，在肿瘤问题中有一个特征量肿瘤大小，在实际中特征量的个数并没有限制，对于无限多的特征量，需要后文的支持向量机的算法来解决。</p>
<h1 id="无监督学习（Unsupervised_Learning）">无监督学习（Unsupervised Learning）</h1><h2 id="定义:无监督学习">定义:无监督学习</h2><p>对于监督学习的每个样本，我们都事先地告诉了每个样本所谓的正确答案（即样本数据集），在无监督学习中，我们没有属性或者标签这个概念，也就是说所有数据看起来都是一样的，如下图所示，左图为监督学习，右图为无监督学习。</p>
<p><img src="/imgs/machine-learning/01-04.png" alt=""></p>
<p>在无监督学习中，没人告诉我们数据如何使用，每个数据点究竟是什么意思，它只告诉我们现在有一个数据集，需要我们找出数据间的结构。对于一个数据集，无监督学习算法能判断该数据集包含的不同聚类，也就是所谓的聚类算法。</p>
<h2 id="示例:实际运用场景">示例:实际运用场景</h2><p>1.在Google新闻中，自动地将不同媒体的关于同一事件的新闻报告的URL聚集到同一标题下。</p>
<p><img src="/imgs/machine-learning/01-05.png" alt=""></p>
<p>2.对于每个个体检测是否拥有某个特定的基因，使用聚类算法来进行基因分类</p>
<p><img src="/imgs/machine-learning/01-06.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="前言">前言</h1><p>最近开始学习C站上的NG的机器学习课程，会把视频中的内容写成笔记方便查阅，待学完后会将全部的笔记整理成PDF。</p>
<h1 id="监督学习（Supervised_Learning）">监督学习（Supervised Learnin]]>
    </summary>
    
      <category term="机器学习" scheme="http://codle.net/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习" scheme="http://codle.net/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hihoCoder编程练习赛：A 买零食]]></title>
    <link href="http://codle.net/2016/03/13/hiho-practice-match2-a/"/>
    <id>http://codle.net/2016/03/13/hiho-practice-match2-a/</id>
    <published>2016-03-13T10:41:44.000Z</published>
    <updated>2016-07-05T08:09:12.405Z</updated>
    <content type="html"><![CDATA[<h1 id="hihoCoder编程练习赛：A_买零食">hihoCoder编程练习赛：A 买零食</h1><p><img src="/imgs/hihocoder.png" alt=""></p>
<h2 id="描述">描述</h2><p>小Ho很喜欢在课间去小卖部买零食。然而不幸的是，这个学期他又有在一教的课，而一教的小卖部姐姐以冷若冰霜著称。第一次去一教小卖部买零食的时候，小Ho由于不懂事买了好一大堆东西，被小卖部姐姐给了一个“冷若冰霜”的眼神，食欲都下降了很多。</p>
<p>从那以后，小Ho就学乖了，去小卖部买东西只敢同时买3包以内的零食，并且价格加起来必须是5的整数倍，方便小卖部姐姐算价格。</p>
<p>但是小Ho不擅长计算，所以他把小卖部里所有零食的价格以及他对这个零食的渴望度都告诉了你，希望你能够帮他计算出在不惹恼小卖部姐姐的前提下，能够买到零食的渴望度之和最高是多少？</p>
<h2 id="输入">输入</h2><p>每个输入文件包含多组测试数据，在每个输入文件的第一行为一个整数Q，表示测试数据的组数。</p>
<p>每组测试数据的第一行为一个正整数N，表示小卖部中零食的数量。</p>
<p>接下来的N行，每行为一个正实数A和一个正整数B，表示这种零食的价格和小Ho对其的渴望度。</p>
<p>一种零食仅有一包。</p>
<p>对于100%的数据，满足1 &lt;= Q &lt;= 10，1&lt;=N&lt;=50，0&lt;A&lt;=10，1&lt;=B&lt;=100。</p>
<p>对于100%的数据，满足A的小数部分仅可能为0.5或0。</p>
<h2 id="输出">输出</h2><p>对于每组测试数据，输出一个整数Ans，表示小Ho可以获得最大的渴望度之和。</p>
<h3 id="样例输入">样例输入</h3><p>1<br>4<br>0.5 6<br>4.5 7<br>5.0 4<br>2.0 9</p>
<h3 id="样例输出">样例输出</h3><p>17</p>
<h2 id="解题思路">解题思路</h2><p>由于N最大只有50，也就是说最多计算量是$C_{50}^3$并不大，所以考虑直接暴力求解。由于看到有两个关联量，在自己做得时候直接就考虑了关联容器map，但是这两个量都是会出现重复的，不是唯一的，所以一直WA了很久才发现这问题，还是老老实实采取数组解决比较快。</p>
<h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFloat</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = (<span class="keyword">int</span>)d;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">fabs</span>(d - a) &lt; <span class="number">1e-8</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Q;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; Q;</span><br><span class="line">	<span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">		<span class="keyword">int</span> N;</span><br><span class="line">		<span class="keyword">double</span> cost[<span class="number">100</span>];</span><br><span class="line">		<span class="keyword">int</span> val[<span class="number">100</span>];</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; cost[i] &gt;&gt; val[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">			<span class="keyword">double</span> c = cost[i];</span><br><span class="line">			<span class="keyword">if</span> (isFloat(c) &amp;&amp; (<span class="keyword">int</span>)c % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				ans = max(ans, val[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">				<span class="keyword">double</span> c = cost[i] + cost[j];</span><br><span class="line">				<span class="keyword">if</span> (isFloat(c) &amp;&amp; (<span class="keyword">int</span>)c % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">					ans = max(ans, val[i] + val[j]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; N; k++) &#123;</span><br><span class="line">					<span class="keyword">double</span> c = cost[i] + cost[j] + cost[k];</span><br><span class="line">					<span class="keyword">if</span> (isFloat(c) &amp;&amp; (<span class="keyword">int</span>)c % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">						ans = max(ans, val[i] + val[j] + val[k]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="hihoCoder编程练习赛：A_买零食">hihoCoder编程练习赛：A 买零食</h1><p><img src="/imgs/hihocoder.png" alt=""></p>
<h2 id="描述">描述</h2><p>小Ho很喜欢在课间去小卖部买零食。]]>
    </summary>
    
      <category term="hiho" scheme="http://codle.net/tags/hiho/"/>
    
      <category term="算法" scheme="http://codle.net/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="习题集" scheme="http://codle.net/categories/%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hihoCoder第七十八周：Shortest Proper Prefix]]></title>
    <link href="http://codle.net/2015/12/28/hiho78/"/>
    <id>http://codle.net/2015/12/28/hiho78/</id>
    <published>2015-12-28T13:23:13.000Z</published>
    <updated>2016-07-05T08:53:50.135Z</updated>
    <content type="html"><![CDATA[<h1 id="hihoCoder第七十八周：Shortest_Proper_Prefix">hihoCoder第七十八周：Shortest Proper Prefix</h1><h2 id="题目">题目</h2><p>Query auto-completion(QAC) is widely used in many search applications. The basic idea is that when you type some string s in the search box several high-frequency queries which have s as a prefix are suggested. We say string s1 has string s2 as a prefix if and only if the first |s2| characters of s1 are the same as s2 where |s2| is the length of s2.</p>
<p><img src="http://media.hihocoder.com//problem_images/20150117/14214822852319.png" alt=""></p>
<p>These days Little Hi has been working on a way to improve the QAC performance. He collected N high-frequency queries. We say a string s is a proper prefix if there are no more than 5 collected queries have s as a prefix. A string s is a shortest proper prefix if s is a proper prefix and all the prefixes of s(except for s itself) are not proper prefixes. Little Hi wants to know the number of shortest proper prefixes given N collected queries.</p>
<p>Hint: the 4 shortest proper prefixes for Sample Input are “ab”, “bb”, “bc” and “be”. Empty string “” is not counted as a proper prefix even if N &lt;= 5.</p>
<p>输入<br>The first line contains N(N &lt;= 10000), the number of collected queries.<br>The following N lines each contain a query.<br>Each query contains only lowercase letters ‘a’-‘z’.<br>The total length of all queries are no more than 2000000.<br>Input may contain identical queries. Count them separately when you calculate the number of queries that have some string as a prefix.</p>
<p>输出<br>Output the number of shortest proper prefixes.</p>
<p>样例输入:<br>12<br>a<br>ab<br>abc<br>abcde<br>abcde<br>abcba<br>bcd<br>bcde<br>bcbbd<br>bcac<br>bee<br>bbb</p>
<p>样例输出:<br>4</p>
<h2 id="大意">大意</h2><p>给定N个单词，求满足下列条件的前缀集合S：</p>
<ul>
<li>集合中任意前缀对应的单词数量小于等于5</li>
<li>对于集合中任意前缀p，p的扩展前缀不属于该集合</li>
</ul>
<p>对于第二个条件，举个例子来说：</p>
<p>假设ab对应了5个单词，abc对应了3个单词，abd对应了2个单词。</p>
<p>因为ab对应的单词数量少于等于5，所以ab属于集合S。虽然abc和abd对应的单词数量均小于等于5，但由于其为ab的扩展，所以不属于S。</p>
<h2 id="解题思路">解题思路</h2><p>我们可以考虑构建Tire树来存储给出的字符串，Tire树如下图所示：</p>
<p><img src="http://media.hihocoder.com/contests/hiho78/hiho78.png" alt=""></p>
<p>这样我们只用对树进行深度优先搜索，找到结点的值小于五就返回，用一个全局变量储存返回的次数即所求的前缀个数。</p>
<h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TireNode &#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;TireNode*&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> str, TireNode* &amp;head)</span> </span>&#123;</span><br><span class="line">	TireNode* p = head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">char</span> ch : str) &#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">auto</span> it = p-&gt;child.begin();</span><br><span class="line">		<span class="keyword">for</span> (; it != p-&gt;child.end(); ++it) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((*it)-&gt;ch == ch) &#123;</span><br><span class="line">				(*it)-&gt;cnt++;</span><br><span class="line">				p = (*it);</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">			TireNode* tmp = <span class="keyword">new</span> TireNode;</span><br><span class="line">			tmp-&gt;ch = ch;</span><br><span class="line">			tmp-&gt;cnt++;</span><br><span class="line">			p-&gt;child.push_back(tmp);</span><br><span class="line">			p = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TireNode* t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t-&gt;cnt &gt; <span class="number">5</span>) &#123;</span><br><span class="line">		<span class="keyword">auto</span> it = t-&gt;child.begin();</span><br><span class="line">		<span class="keyword">for</span> (; it != t-&gt;child.end(); ++it)</span><br><span class="line">			dfs(*it);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">string</span> tmp;</span><br><span class="line">	TireNode* t = <span class="keyword">new</span> TireNode;</span><br><span class="line">	t-&gt;cnt = <span class="number">6</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">		insert(tmp, t);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(t);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="hihoCoder第七十八周：Shortest_Proper_Prefix">hihoCoder第七十八周：Shortest Proper Prefix</h1><h2 id="题目">题目</h2><p>Query auto-completion(QAC) is]]>
    </summary>
    
      <category term="hiho" scheme="http://codle.net/tags/hiho/"/>
    
      <category term="算法" scheme="http://codle.net/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="习题集" scheme="http://codle.net/categories/%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hihoCoder第七十二周：Disk Storage]]></title>
    <link href="http://codle.net/2015/11/16/hiho72/"/>
    <id>http://codle.net/2015/11/16/hiho72/</id>
    <published>2015-11-16T12:44:23.000Z</published>
    <updated>2016-07-05T08:53:43.515Z</updated>
    <content type="html"><![CDATA[<h1 id="hihoCoder第七十二周：Disk_Storage">hihoCoder第七十二周：Disk Storage</h1><h2 id="题目">题目</h2><p><img src="http://media.hihocoder.com//problem_images/20150103/14202824928356.png" alt=""></p>
<p>Little Hi and Little Ho have a disk storage. The storage’s shape is a truncated cone of height H. R+H is radius of top circle and R is radius of base circle.<br>Little Ho buys N disks today. Every disk is a cylinder of height 1. Little Ho wants to put these disk into the storage under below constraints:</p>
<ol>
<li>Every disk is placed horizontally. Its axis must coincide with the axis of storage.</li>
<li>Every disk is either place on the bottom surface or on another disk.</li>
<li>Between two neighboring disks in the storage, the upper one’s radius minus the lower one’s radius must be less than or equal to M.</li>
</ol>
<p>Little Ho wants to know how many disks he can put in the storage at most.</p>
<p>输入<br>Input contains only one testcase.<br>The first line contains 4 integers: N(1 &lt;= N &lt;= 100000), M, H, R(1 &lt;= M, R, H &lt;= 100000000).<br>The second line contains N integers, each number prepresenting the radius of a disk. Each radius is no more than 100000000.</p>
<p>输出<br>Output the maximum possible number of disks can be put into the storage.</p>
<p>样例输入<br>5 1 10 3<br>1 3 4 5 10<br>样例输出<br>4</p>
<h2 id="大意">大意</h2><p>在一个圆台中装圆形碟片，求问满足下面要求后最多能放几个圆碟：</p>
<ul>
<li>每个圆碟都放在中轴线上，每个圆碟都是挨着的</li>
<li>圆碟要么放在圆碟上要么放在水平面上</li>
<li>相邻两个圆碟，上面那个的半径减去下面那个的半径必须小于等于M</li>
</ul>
<h2 id="解题思路">解题思路</h2><p>上面那个减去下面那个半径小于等于M，并没有说是绝对值，因此从下到上假设摆成3-&gt;2-&gt;1这种也是满足要求的，因为都是负数小于M。因此解题思路就很明显了，先将圆碟按照半径排序，遍历直到有半径等于或者稍小于底面半径圆盘为止，显然之前已经被遍历的圆碟是一定能放的（只用按照从大到小的顺序摆在最上面即可），那么就从这个圆盘开始，依次查找满足M和R+H条件的圆盘即可。结果摆放如图所示：<br><img src="/imgs/hiho72.png" alt=""></p>
<h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, h, r;</span><br><span class="line">	<span class="keyword">int</span> num1, num2;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; h &gt;&gt; r;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">100001</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	sort(a, a + n);</span><br><span class="line">	num1 = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">if</span> (a[<span class="number">0</span>] &gt; r) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	num2 = num1;</span><br><span class="line">	cnt++;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; r + cnt)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[i] - num1 &gt; m)</span><br><span class="line">			<span class="keyword">if</span> (a[i] &lt;= r) &#123;</span><br><span class="line">				num2 = a[i];</span><br><span class="line">				num1 = num2;</span><br><span class="line">				cnt = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			num1 = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; min(i, h) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="hihoCoder第七十二周：Disk_Storage">hihoCoder第七十二周：Disk Storage</h1><h2 id="题目">题目</h2><p><img src="http://media.hihocoder.com//problem_ima]]>
    </summary>
    
      <category term="hiho" scheme="http://codle.net/tags/hiho/"/>
    
      <category term="算法" scheme="http://codle.net/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="习题集" scheme="http://codle.net/categories/%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法学习：动态规划]]></title>
    <link href="http://codle.net/2015/11/16/dp-pdf/"/>
    <id>http://codle.net/2015/11/16/dp-pdf/</id>
    <published>2015-11-16T07:10:32.000Z</published>
    <updated>2015-12-31T12:46:46.596Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文翻译自斯坦福大学的算法介绍课程PDF。英语水平不高，部分翻译可能比较生硬，还望见谅</p>
<h2 id="什么是动态规划">什么是动态规划</h2><blockquote>
<p>“通过将复杂问题分解为简单的子问题的方法” ————维基百科</p>
</blockquote>
<h2 id="动态规划的步骤">动态规划的步骤</h2><ol>
<li>定义子问题</li>
<li>找到子问题的递推关系</li>
<li>发现并解决每种基本情况</li>
</ol>
<h2 id="样例1:_区间型动态规划">样例1: 区间型动态规划</h2><h3 id="问题描述:">问题描述:</h3><p>给一个数n，求有多少种方案能通过1，3，4求和得到n？</p>
<h3 id="示例:">示例:</h3><p>对于一个数n = 5,答案是6<br>　５　＝　１　＋　１　＋　１　＋　１　＋　１<br>　　　＝　１　＋　１　＋　３<br>　　　＝　１　＋　３　＋　１<br>　　　＝　３　＋　１　＋　１<br>　　　＝　１　＋　４<br>　　　＝　４　＋　１</p>
<h3 id="定义子问题">定义子问题</h3><p>设$D_n$是用1,3,4求和得到n的方案总数</p>
<h3 id="找到子问题的递推关系">找到子问题的递推关系</h3><ul>
<li>思考一种可能的解决方案：n = $x_1 + x_2 + … + x_m$</li>
<li>如果$x_m$ = 1，那么剩下就需要求和至n-1</li>
<li>因此，以$x_m = 1$结尾的方案数量就等同于$D_{n-1}$ </li>
<li>对其他几种选择也使用上面的方法($x_m=3，x_m=4$)</li>
</ul>
<p>那么递推关系就出来:<br>$D_n = D_{n-1} + D_{n-3} + D_{n-4}$
　　</p>
<h3 id="解决基本情况">解决基本情况</h3><ul>
<li>$D_0 = 1$</li>
<li>$D_n = 0$ 用于初始化每个n的方案总数</li>
<li>当然，我们也可以设置：$D_0 = D_1 = D_2 = 1 且 D_3 = 2$</li>
</ul>
<h3 id="实现">实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D[<span class="number">0</span>] = D[<span class="number">1</span>] = D[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">D[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">4</span>; i &lt;= n; i++)</span><br><span class="line">    D[i] = D[i-<span class="number">1</span>] + D[i-<span class="number">3</span>] + D[i-<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<h2 id="例题:_POJ_2663:Tri_Tiling">例题: POJ 2663:Tri Tiling</h2><h3 id="问题描述:-1">问题描述:</h3><p>给一个数n，找出有多少种方案使用2 × 1的方块来填充3 × n的矩形</p>
<h3 id="示例：">示例：</h3><p>这里有一种填充n = 12的可行方案<br><img src="http://poj.org/images/2663_1.jpg" alt="&quot;n = 12&quot;"></p>
<h3 id="定义子问题-1">定义子问题</h3><p>设$D_n$是填充3 × n矩形的总方案数</p>
<h3 id="找出递推关系">找出递推关系</h3><p>很明显可以分析得出n为奇数时无法拼出矩形，那么下面都针对偶数的情况进行分析。<br>在n-2是拼好的情况下，要拼出n层的矩形有如下三种拼接方式。<br><img src="/imgs/dp001.png" alt=""></p>
<p>此时可以得出 $D_n = 3 × D_{n-2}$</p>
<p>但这只是解决了当第n-2是矩形的情况下的子问题。</p>
<p>那么当n-2不是矩形时能否让n层拼出矩形呢？<br>有如下两种方案可以实现：<br><img src="/imgs/dp002.png" alt=""></p>
<p>此时$D_n = ?$<br>$D_n = 3 × D_{n-2} + 2^{(n-2)/2}$?</p>
<p>这里显然不能把每个关节点想成是独立的问题来求幂运算，因为一旦一个关节开始按照方案来摆放，后面的摆放就已经是固定的了！不然无法完整的拼出一整个矩形。如下图：<br><img src="/imgs/dp003.png" alt=""><br>一旦按照黄色部分拼接，那么后面到n-2的地方都必须按照蓝色的方式进行拼接。<br>所以，正确的递推关系应该是:<br>$D_n = 3 × D_{n-2} + 2 × D_{n-4} + 2 × D_{n-6} + … + 2 × D_{0}$<br>我们对上式化简，左右同时减去$D_{n-2} = 3 × D_{n-4} + 2 × D_{n-6} + … + 2 × D_{0}$<br>得到：<br>$D_n - D_{n-2} = 3 × D_{n-2} - D_{n-4}$<br>$D_n = 4 × D_{n-2} - D_{n-4}$</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文翻译自斯坦福大学的算法介绍课程PDF。英语水平不高，部分翻译可能比较生硬，还望见谅</p>
<h2 id="什么是动态规划">什么是动态规划</h2><blockquote>
<p>“通过将复杂问题分解为简单的子问题的方法” ———]]>
    </summary>
    
      <category term="算法" scheme="http://codle.net/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习" scheme="http://codle.net/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法学习：回文串]]></title>
    <link href="http://codle.net/2015/11/03/ispalindrome/"/>
    <id>http://codle.net/2015/11/03/ispalindrome/</id>
    <published>2015-11-03T09:57:40.000Z</published>
    <updated>2016-07-05T08:55:32.651Z</updated>
    <content type="html"><![CDATA[<h1 id="算法学习：回文串">算法学习：回文串</h1><h2 id="前言">前言</h2><p>所谓回文串，就是从开头顺序读或者从结尾向前面读都一样的字符串（或链表），如abcdcba，madam。回文串能够轻易考验对字符串的应用，因此关于回文串的题目也是非常的广泛。</p>
<h2 id="判断回文">判断回文</h2><h3 id="题目描述">题目描述</h3><p>给定一个字符串，如何判断这个字符串是否是回文串。<br><img src="/imgs/algorithm.jpg" alt=""><br><a id="more"></a></p>
<h3 id="分析与解法：">分析与解法：</h3><h4 id="解法一：两头向中间扫">解法一：两头向中间扫</h4><p>找到这个字符串的开头和结尾，然后从两端开始向中间扫描，扫描过程中，如果对应的字符都相同，那么说明这个字符串回文。当前端超过或者等于后端时候结束扫描。<br>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!s.size())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> back = s.size() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (front &lt; back) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[front]!=s[back])</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		front++;</span><br><span class="line">		back--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度O(n),空间复杂度O(1)。</p>
<h4 id="解法二：中间向两头扫">解法二：中间向两头扫</h4><p>找到中间元素，然后向两端以此扫描查看是否相同，难点在于找到中点后的起点位置，字符串长度是奇数或者偶数是不同的。<br>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!s.size())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> n = s.size();</span><br><span class="line">	<span class="keyword">int</span> front, back;</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		front = n / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">		back = n / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		front = back = n / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (; front &gt;= <span class="number">0</span>; front--, back++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[front] != s[back])</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间空间复杂度和解法一相同，分别是O(n)和O(1)。</p>
<h2 id="链表判断回文">链表判断回文</h2><h3 id="题目描述-1">题目描述</h3><p>判断一条单向链表是不是回文</p>
<h3 id="分析与算法">分析与算法</h3><p>由于是单链表，单向传递无法使用两个指针来扫描。可以扫描一次找到中点，然后再来进行一次扫描，从开头和中点来开始扫描进行比较，但是这样扫描了两次会增加时间复杂度。我们这里考虑使用快慢指针的方法，用两个指针来开始扫描，一个指针每次递增一步，一个每次递增两步。当快的指针到达链表尾部是，慢的指针就到达了链表的中点。然后我们倒置后半段链表与开头进行比较判断是否是回文串。<br>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(Node* t)</span> </span>&#123;</span><br><span class="line">	Node* slow = t;</span><br><span class="line">	Node* flast = t;</span><br><span class="line">	Node* l = <span class="keyword">new</span> Node;</span><br><span class="line">	Node* p;</span><br><span class="line">	Node* tl;</span><br><span class="line">	<span class="keyword">while</span> (flast-&gt;next) &#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		flast = flast-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (flast-&gt;next)</span><br><span class="line">			flast = flast-&gt;next;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	p = slow;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">		Node* temp = <span class="keyword">new</span> Node(p-&gt;next-&gt;val);</span><br><span class="line">		temp-&gt;next = l-&gt;next;</span><br><span class="line">		l-&gt;next = temp;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (p = t-&gt;next, tl = l-&gt;next; tl != <span class="literal">NULL</span>; p = p-&gt;next, tl = tl-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val != tl-&gt;val)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="算法学习：回文串">算法学习：回文串</h1><h2 id="前言">前言</h2><p>所谓回文串，就是从开头顺序读或者从结尾向前面读都一样的字符串（或链表），如abcdcba，madam。回文串能够轻易考验对字符串的应用，因此关于回文串的题目也是非常的广泛。</p>
<h2 id="判断回文">判断回文</h2><h3 id="题目描述">题目描述</h3><p>给定一个字符串，如何判断这个字符串是否是回文串。<br><img src="/imgs/algorithm.jpg" alt=""><br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://codle.net/tags/C/"/>
    
      <category term="算法" scheme="http://codle.net/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习" scheme="http://codle.net/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构：二叉树（C++版）]]></title>
    <link href="http://codle.net/2015/10/29/binary-tree/"/>
    <id>http://codle.net/2015/10/29/binary-tree/</id>
    <published>2015-10-29T12:48:30.000Z</published>
    <updated>2016-07-05T09:00:18.735Z</updated>
    <content type="html"><![CDATA[<h1 id="数据结构：二叉树（C++版）">数据结构：二叉树（C++版）</h1><h2 id="二叉树的定义">二叉树的定义</h2><p>二叉树是每个节点最多有两个子树的树形结构，二叉树的子树有左右之分，其次序不能颠倒。<br>其中：</p>
<ul>
<li>二叉树第i层至多有$2^{i-1}$个节点（节点最多，则说明前面层都是满的，则每层都是上一层的两倍，第一层有$2^0$=1个节点）；</li>
<li>深度为k的二叉树至多有$2^{k-1}$个节点（即是说k-1层全满的情况，那么每层分别有$2^0$,$2^1$,$2^2$…$2^{k-1}$个节点，等比数列求和可得$2^k-1$）；</li>
</ul>
<p>一棵深度为k，且有$2^{k-1}$个节点称之为满二叉树；深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树。</p>
<p><img src="/imgs/useful.png" alt=""><br><a id="more"></a></p>
<h2 id="二叉树的储存">二叉树的储存</h2><h3 id="链式存储">链式存储</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">Node</span><span class="identifier"> </span><span class="title">&#123;  </span><br><span class="line">	ElemType</span> val;	//本结点储存值  </span><br><span class="line">	<span class="keyword">Node</span><span class="identifier"></span><span class="title">* left</span>;     //结点指针用于储存左子树  </span><br><span class="line">	<span class="keyword">Node</span><span class="identifier"></span><span class="title">* right</span>;	//结点指针用于储存右子树  </span><br><span class="line">        //构造函数，方便调用关键字new来构造节点  </span><br><span class="line">	<span class="keyword">Node</span><span class="identifier"></span><span class="title">(ElemType</span> v=<span class="number">0</span>) &#123;  </span><br><span class="line">		val = v;  </span><br><span class="line">		left = right = NULL;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>链式存储也是最常见的二叉树存储方式</p>
<h3 id="数组存储">数组存储</h3><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElemType <span class="keyword">val</span>[T];    <span class="comment">//T=2^k-1 k为二叉树深度</span></span><br></pre></td></tr></table></figure>
<p>数组的长度就是把当前二叉树当成满二叉树的情况下的结点数。假设一个父节点的下标序号是i，那么：</p>
<ul>
<li>左孩子的结点下标为i*2;</li>
<li>右孩子的结点下标为i*2+1;</li>
</ul>
<h2 id="二叉树的一些操作">二叉树的一些操作</h2><h3 id="二叉树的遍历">二叉树的遍历</h3><p>对于一个二叉树，遍历是最基本的操作，遍历二叉树即是说按照一定规则走完整个二叉树，使得每个结点被访问一次且只被访问一次。二叉树的遍历操作有：前序，中序，后序以及层序遍历。</p>
<h4 id="先序遍历">先序遍历</h4><p>先序遍历的遍历顺序是先访问根节点，然后访问左节点，最后访问右节点，算法实现如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> preOrderView(Node* T) &#123;		<span class="comment">//一个递归函数</span></span><br><span class="line">	<span class="comment">//当前判断当前结点是否为空，为空就回溯</span></span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		cout &lt;&lt; T<span class="subst">-&gt;</span>val &lt;&lt; <span class="string">" "</span>;	<span class="comment">//打印当前结点的值，即是访问根节点</span></span><br><span class="line">		preOrderView(T<span class="subst">-&gt;</span>left);	<span class="comment">//访问当前节点的左节点</span></span><br><span class="line">		preOrderView(T<span class="subst">-&gt;</span>right);	<span class="comment">//访问当前节点的右节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="中序遍历">中序遍历</h4><p>中序遍历的遍历顺序是左–&gt;根–&gt;右，算法与先序遍历基本一致:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> inOrdereView(Node* T) &#123;		<span class="comment">//一个递归函数</span></span><br><span class="line">	<span class="comment">//当前判断当前结点是否为空，为空就回溯</span></span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		inOrdereView(T<span class="subst">-&gt;</span>left);	<span class="comment">//访问当前节点的左节点</span></span><br><span class="line">		cout &lt;&lt; T<span class="subst">-&gt;</span>val &lt;&lt; <span class="string">" "</span>;	<span class="comment">//打印当前结点的值，即是访问根节点</span></span><br><span class="line">		inOrdereView(T<span class="subst">-&gt;</span>right);	<span class="comment">//访问当前节点的右节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="后序遍历">后序遍历</h4><p>后序遍历的遍历顺序是左–&gt;右–&gt;根，算法与上述两个基本相同:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> postOrdereView(Node* T) &#123;			<span class="comment">//一个递归函数</span></span><br><span class="line">	<span class="comment">//当前判断当前结点是否为空，为空就回溯</span></span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		postOrdereView(T<span class="subst">-&gt;</span>left);	<span class="comment">//访问当前节点的左节点</span></span><br><span class="line">		postOrdereView(T<span class="subst">-&gt;</span>right);	<span class="comment">//访问当前节点的右节点</span></span><br><span class="line">		cout &lt;&lt; T<span class="subst">-&gt;</span>val &lt;&lt; <span class="string">" "</span>;		<span class="comment">//打印当前结点的值，即是访问根节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="层序遍历">层序遍历</h4><p>不同于上述三种遍历，层序遍历即是一层一层的访问二叉树的节点，使用的算法思想是广度优先搜索，使用辅助队列来存储每一层的节点。算法实现如下:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> levelOrderView(Node* T) &#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;Node*&gt; q;				<span class="comment">//声明一个队列，这里使用了STL,也可以自己写</span></span><br><span class="line">	Node* t;				<span class="comment">//存取队列元素</span></span><br><span class="line">	q<span class="built_in">.</span>push(T);				<span class="comment">//把根节点放入队列</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="subst">!</span>q<span class="built_in">.</span>empty()) &#123;			<span class="comment">//当队列不为空的时候执行循环</span></span><br><span class="line">		t = q<span class="built_in">.</span>front();			<span class="comment">//t取队头元素</span></span><br><span class="line">		<span class="keyword">if</span> (t<span class="subst">-&gt;</span>left)			<span class="comment">//如果t的左孩子不为空，那么放入队列中</span></span><br><span class="line">			q<span class="built_in">.</span>push(t<span class="subst">-&gt;</span>left);</span><br><span class="line">		<span class="keyword">if</span> (t<span class="subst">-&gt;</span>right)			<span class="comment">//同上</span></span><br><span class="line">			q<span class="built_in">.</span>push(t<span class="subst">-&gt;</span>right);</span><br><span class="line">		q<span class="built_in">.</span>pop();			<span class="comment">//抛出队头元素</span></span><br><span class="line">		cout &lt;&lt; t<span class="subst">-&gt;</span>val &lt;&lt; <span class="string">" "</span>;		<span class="comment">//打印队头元素的值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="通过遍历结果建树">通过遍历结果建树</h3><p>前面我们讲述了三种基本的遍历二叉树方法（前序，中序，后序遍历），那么下面我们将讲述如何通过前序和中序序列或者后序和中序序列来构建这颗二叉树。</p>
<h4 id="前序和中序序列建树">前序和中序序列建树</h4><p>在前序遍历中，遍历二叉树的顺序是根–&gt;左–&gt;右的顺序，而在中序遍历中，遍历顺序是左–&gt;根–&gt;右的顺序。在两者生成的遍历序列中，我们可以很快发现，前序遍历的第一个元素就是该二叉树的根节点，然后再去中序遍历中找到这个元素，因为中序是左–&gt;根–&gt;右的遍历顺序，那么在根节点左侧的字符串就是该根节点的左子树，右侧的字符串就是该节点的右子树。那么对子树，我们有可以从前序遍历中找到相应根节点然后重复做上述步骤，这样就完成了一棵二叉树的建立。由于步骤是一个重复的过程，我们可以使用递归的方式来进行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="built_in">string</span> inOrder, <span class="built_in">string</span> preOrder, Node* &amp;t)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> inL, inR, preL, preR;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;                      <span class="comment">//标志变量用于判断是否找到根节点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inOrder.size(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inOrder[i] == preOrder[<span class="number">0</span>]) &#123;    <span class="comment">//查找根节点</span></span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;              	<span class="comment">//在没找到根节点时，把遍历的字符串放入左子树串</span></span><br><span class="line">			inL.push_back(inOrder[i]);</span><br><span class="line">			preL.push_back(preOrder[i + <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;                              	<span class="comment">//找到了后就放入右子树串</span></span><br><span class="line">			inR.push_back(inOrder[i]);</span><br><span class="line">			preR.push_back(preOrder[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;val = preOrder[<span class="number">0</span>];                   <span class="comment">//把当前根值赋给根节点</span></span><br><span class="line">	<span class="keyword">if</span> (inL.size()) &#123;                       <span class="comment">//如果左子树串不为空，那么递归调用，对左子树进行构树</span></span><br><span class="line">		t-&gt;left = <span class="keyword">new</span> Node;</span><br><span class="line">		buildTree(inL, preL, t-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (inR.size()) &#123;                       <span class="comment">//如果右子树串不空，就对右子树构树。</span></span><br><span class="line">		t-&gt;right = <span class="keyword">new</span> Node;</span><br><span class="line">		buildTree(inR, preR, t-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="后序和中序序列建树">后序和中序序列建树</h4><p>后序和中序序列建树的方法大致思路相同，只是在寻找根节点的方法不同，因为后序遍历的顺序是左–&gt;右–&gt;根，所以后序遍历的最后一个元素是根节点，和前序遍历的首元素不同。其他思路可以参考上文，下面是代码的实现:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree2</span><span class="params">(<span class="built_in">string</span> inOrder, <span class="built_in">string</span> postOrder, Node* &amp;t)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> inL, inR, postL, postR;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inOrder.size(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inOrder[i] == postOrder[postOrder.size() - <span class="number">1</span>]) &#123;</span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">			inL.push_back(inOrder[i]);</span><br><span class="line">			postL.push_back(postOrder[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			inR.push_back(inOrder[i]);</span><br><span class="line">			postR.push_back(postOrder[i - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;val = postOrder[postOrder.size() - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (inL.size()) &#123;</span><br><span class="line">		t-&gt;left = <span class="keyword">new</span> Node;</span><br><span class="line">		buildTree2(inL, postL, t-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (inR.size()) &#123;</span><br><span class="line">		t-&gt;right = <span class="keyword">new</span> Node;</span><br><span class="line">		buildTree2(inR, postR, t-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="数据结构：二叉树（C++版）">数据结构：二叉树（C++版）</h1><h2 id="二叉树的定义">二叉树的定义</h2><p>二叉树是每个节点最多有两个子树的树形结构，二叉树的子树有左右之分，其次序不能颠倒。<br>其中：</p>
<ul>
<li>二叉树第i层至多有$2^{i-1}$个节点（节点最多，则说明前面层都是满的，则每层都是上一层的两倍，第一层有$2^0$=1个节点）；</li>
<li>深度为k的二叉树至多有$2^{k-1}$个节点（即是说k-1层全满的情况，那么每层分别有$2^0$,$2^1$,$2^2$…$2^{k-1}$个节点，等比数列求和可得$2^k-1$）；</li>
</ul>
<p>一棵深度为k，且有$2^{k-1}$个节点称之为满二叉树；深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树。</p>
<p><img src="/imgs/useful.png" alt=""><br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://codle.net/tags/C/"/>
    
      <category term="数据结构" scheme="http://codle.net/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构" scheme="http://codle.net/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用hexo搭建个人博客]]></title>
    <link href="http://codle.net/2015/10/29/how-to-build-hexo/"/>
    <id>http://codle.net/2015/10/29/how-to-build-hexo/</id>
    <published>2015-10-29T07:08:54.000Z</published>
    <updated>2016-07-05T08:56:14.589Z</updated>
    <content type="html"><![CDATA[<h1 id="使用hexo搭建个人博客">使用hexo搭建个人博客</h1><h2 id="前言">前言</h2><p>折腾了两天终于做好了这个博客站，相比于wordpress+虚拟空间的组合，使用Github Page+hexo无疑显得要更加轻便与稳定。<br>下面就来谈一谈是如何在Github上搭建一个hexo博客的。</p>
<p><img src="/imgs/post1.jpg" alt="&quot;Hexo&quot;"></p>
<a id="more"></a>
<h2 id="搭建环境">搭建环境</h2><p>hexo是一个基于node.js的静态博客框架，因此电脑需要安装node.js环境，同时也需要Git软件用于上传博客文件</p>
<ul>
<li><a href="http://nodejs.org" target="_blank" rel="external">Node.js</a></li>
<li><a href="http://git-scm.com/" target="_blank" rel="external">Git</a></li>
</ul>
<h2 id="注册GitHub">注册GitHub</h2><p>访问<a href="http://www.github.com/" target="_blank" rel="external">GitHub</a>官网注册一个账号。</p>
<p>邮箱请确保能收到消息，GitHub上的消息都是通过邮件通知的。</p>
<h2 id="配置和使用GitHub">配置和使用GitHub</h2><p>在注册完GitHub后，进行一些必要的SSH配置，以确保本地Git项目能与远程的Github联系。</p>
<h3 id="检查SSH_Keys">检查SSH Keys</h3><p>首先检查电脑上现有的SSH Keys，打开之前安装的Git Bash，输入：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh &#26816;&#26597;&#26412;&#26426;ssh&#23494;&#38053;</span><br></pre></td></tr></table></figure></p>
<p>如果提示: No such file or directory 说明是第一次使用git。</p>
<h3 id="生成新的SSH_Key：">生成新的SSH Key：</h3><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"邮件地址@youremail.com"</span></span><br><span class="line">Generating <span class="keyword">public</span>/<span class="keyword">private</span> rsa <span class="keyword">key</span> pair.</span><br><span class="line">Enter file <span class="keyword">in</span> which <span class="keyword">to</span> save the <span class="keyword">key</span> (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>邮件地址填入你自己的邮箱地址</li>
<li>-C是大写的C，且每个-前面都是有一个空格的</li>
</ul>
<p>然后系统会要求你创建密码：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):<span class="variable">&lt;输入加密串&gt;</span></span><br><span class="line">Enter same passphrase again:<span class="variable">&lt;再次输入加密串&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这个密码在你之后提交项目时使用，如果为空的话在提交项目时可以不输入。这是为了防止别人在你的项目里面提交文件。</p>
<p>注意：输入密码时候不会显示字符或者*，直接输完回车即可。</p>
<p>看到显示一个方框图形就表示成功设置SSH Key了。</p>
<h3 id="添加SSH_Key到GitHub">添加SSH Key到GitHub</h3><p>本机设置SSH Key后，需要添加到GitHub上，已完成SSH链接的设置。</p>
<ol>
<li>用记事本打开本地C:\Users\用户名.ssh\id_rsa.pub文件。这个文件里面内容是刚刚生成的密钥。如果看不到文件，你需要设置显示隐藏文件。ctrl+a复制全部文本。</li>
<li>登陆github。点击右上角头像Settings-&gt;SSH Keys-&gt;Add SSH Key。title可以随便取名，把刚才复制的内容粘贴进Key里面去。</li>
<li>点击Add Key完成设置。</li>
</ol>
<h3 id="测试SSH_Key">测试SSH Key</h3><p>输入下面的命令，看看设置是否成功，请勿改动命令内容:<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh -<span class="constant">T</span> git<span class="variable">@github</span>.com</span><br></pre></td></tr></table></figure></p>
<p>会出现如下内容:<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity <span class="keyword">of</span> host <span class="comment">'github.com (207.97.227.239)' can't be established.</span></span><br><span class="line">RSA <span class="keyword">key</span> fingerprint <span class="keyword">is</span> <span class="number">16</span>:<span class="number">27</span>:ac:a5:<span class="number">76</span>:<span class="number">28</span>:<span class="number">2</span>d:<span class="number">36</span>:<span class="number">63</span>:<span class="number">1</span>b:<span class="number">56</span>:<span class="number">4</span>d:eb:df:a6:<span class="number">48.</span></span><br><span class="line">Are you sure you want <span class="keyword">to</span> <span class="keyword">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure></p>
<p>输入yes即可，如果之前设置了SSH Key密码，那么还会要求输入之前的密码<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi user! You've successfully authenticated, <span class="keyword">but</span> GitHub <span class="keyword">does</span> <span class="keyword">not</span> provide shell access.</span><br></pre></td></tr></table></figure></p>
<h3 id="设置用户信息">设置用户信息</h3><p>Git通过用户的名字和邮箱来上传文件，输入下面的代码进行个人信息的设置。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user<span class="class">.name</span> <span class="string">"user"</span><span class="comment">//用户名</span></span><br><span class="line">$ git config --global user<span class="class">.email</span>  <span class="string">"user@gmail.com"</span><span class="comment">//填写自己的邮箱</span></span><br></pre></td></tr></table></figure></p>
<h3 id="SSH_Key配置成功">SSH Key配置成功</h3><p>如果中途出现问题，请按照步骤从头再来一次。</p>
<h2 id="使用GitHub_Page建立博客">使用GitHub Page建立博客</h2><p>GitHub Page是GitHub提供给每个用户的一个功能。可以通过username.github.io的方式进行访问，每个用户名下只能创建一个。</p>
<h3 id="建立仓库">建立仓库</h3><p>登陆GitHub，点击 New Repository 填写项目信息。</p>
<ul>
<li>project name ：username.github.io</li>
<li>description :填写项目描述，可以不写</li>
</ul>
<p>注意：username一定是你的Github名字。</p>
<h2 id="使用hexo">使用hexo</h2><h3 id="安装">安装</h3><p>打开Git Bash，运行下面的命令：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> hexo</span></span><br></pre></td></tr></table></figure></p>
<p>自己在磁盘中建一个名为hexo的文件夹，在Git Bash中使用cd命令进入hexo文件夹下，运行下面的命令:<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo init</span><br></pre></td></tr></table></figure></p>
<p>就完成了hexo的本地博客安装。</p>
<h3 id="本地浏览">本地浏览</h3><p>我们可以通过下面的命令在本地查看博客：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo s</span><br></pre></td></tr></table></figure></p>
<p>在浏览器输入 localhost:4000 查看。</p>
<h3 id="_config-yml文件">_config.yml文件</h3><p>hexo文件根目录下的_config.yml存储了一些关于博客的基础设置，可以自己查看酌情修改。而theme里面的主题文件对应的_config.yml则是修改主题设置的。</p>
<h3 id="上载自己的博客程序">上载自己的博客程序</h3><p>部署到GitHub前需要配置根目录下的_config.yml文件。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">    <span class="attribute">type</span>: github</span><br><span class="line">    <span class="attribute">repository</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:username/username.github.com.git</span><br><span class="line">    <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></p>
<p>之后执行下列指令即可完成部署:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="keyword">g</span></span><br><span class="line">hexo <span class="literal">d</span></span><br></pre></td></tr></table></figure></p>
<p>也可以直接输入：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="keyword">d</span> -<span class="keyword">g</span></span><br></pre></td></tr></table></figure></p>
<p>即完成了博客的上传。上传完成后就可以通过username.github.io访问你的博客了。</p>
<h2 id="DNS解析">DNS解析</h2><p>如何将博客解析到自己的域名上？可以通过如下设置完成：<br>添加两条A记录:</p>
<ul>
<li>192.30.252.153</li>
<li>192.30.252.154</li>
</ul>
<p>在hexo\sourcex下新建记事本，写上自己的域名，然后改名为CNAME(注意没有后缀名)，然后上载博客。<br>在域名管理中添加CNAME解析，主机记录添加wwww,记录值改为 username.github.io 。</p>
<h2 id="后记">后记</h2><p>感谢各位大大提供的教程:</p>
<ul>
<li><a href="http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></li>
<li><a href="http://yangjian.me/workspace/building-blog-with-hexo/" target="_blank" rel="external">使用hexo搭建博客</a></li>
</ul>
<p>附上需要的链接：</p>
<ul>
<li><a href="https://hexo.io/" target="_blank" rel="external">Hexo官网（是台湾前辈开发的，因此很多文档都带有繁中）</a></li>
<li><a href="https://hexo.io/" target="_blank" rel="external">GitHub Page（如果Ip无法解析了，请及时来看）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="使用hexo搭建个人博客">使用hexo搭建个人博客</h1><h2 id="前言">前言</h2><p>折腾了两天终于做好了这个博客站，相比于wordpress+虚拟空间的组合，使用Github Page+hexo无疑显得要更加轻便与稳定。<br>下面就来谈一谈是如何在Github上搭建一个hexo博客的。</p>
<p><img src="/imgs/post1.jpg" alt="&quot;Hexo&quot;"></p>]]>
    
    </summary>
    
      <category term="blog" scheme="http://codle.net/tags/blog/"/>
    
      <category term="hexo" scheme="http://codle.net/tags/hexo/"/>
    
      <category term="博客相关" scheme="http://codle.net/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
</feed>
