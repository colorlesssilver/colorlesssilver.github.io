<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Silver's Codle]]></title>
  <subtitle><![CDATA[无比芜杂的心绪]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://codle.net/"/>
  <updated>2015-12-28T13:28:04.237Z</updated>
  <id>http://codle.net/</id>
  
  <author>
    <name><![CDATA[Silver]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[hihoCoder第七十八周：Shortest Proper Prefix]]></title>
    <link href="http://codle.net/2015/12/28/hiho78/"/>
    <id>http://codle.net/2015/12/28/hiho78/</id>
    <published>2015-12-28T13:23:13.000Z</published>
    <updated>2015-12-28T13:28:04.237Z</updated>
    <content type="html"><![CDATA[<h1 id="hihoCoder第七十八周：Shortest_Proper_Prefix">hihoCoder第七十八周：Shortest Proper Prefix</h1><h2 id="题目">题目</h2><p>Query auto-completion(QAC) is widely used in many search applications. The basic idea is that when you type some string s in the search box several high-frequency queries which have s as a prefix are suggested. We say string s1 has string s2 as a prefix if and only if the first |s2| characters of s1 are the same as s2 where |s2| is the length of s2.</p>
<p><img src="http://media.hihocoder.com//problem_images/20150117/14214822852319.png" alt=""></p>
<p>These days Little Hi has been working on a way to improve the QAC performance. He collected N high-frequency queries. We say a string s is a proper prefix if there are no more than 5 collected queries have s as a prefix. A string s is a shortest proper prefix if s is a proper prefix and all the prefixes of s(except for s itself) are not proper prefixes. Little Hi wants to know the number of shortest proper prefixes given N collected queries.</p>
<p>Hint: the 4 shortest proper prefixes for Sample Input are “ab”, “bb”, “bc” and “be”. Empty string “” is not counted as a proper prefix even if N &lt;= 5.</p>
<p>输入<br>The first line contains N(N &lt;= 10000), the number of collected queries.<br>The following N lines each contain a query.<br>Each query contains only lowercase letters ‘a’-‘z’.<br>The total length of all queries are no more than 2000000.<br>Input may contain identical queries. Count them separately when you calculate the number of queries that have some string as a prefix.</p>
<p>输出<br>Output the number of shortest proper prefixes.</p>
<p>样例输入:<br>12<br>a<br>ab<br>abc<br>abcde<br>abcde<br>abcba<br>bcd<br>bcde<br>bcbbd<br>bcac<br>bee<br>bbb</p>
<p>样例输出:<br>4</p>
<h2 id="大意">大意</h2><p>给定N个单词，求满足下列条件的前缀集合S：</p>
<ul>
<li>集合中任意前缀对应的单词数量小于等于5</li>
<li>对于集合中任意前缀p，p的扩展前缀不属于该集合</li>
</ul>
<p>对于第二个条件，举个例子来说：</p>
<p>假设ab对应了5个单词，abc对应了3个单词，abd对应了2个单词。</p>
<p>因为ab对应的单词数量少于等于5，所以ab属于集合S。虽然abc和abd对应的单词数量均小于等于5，但由于其为ab的扩展，所以不属于S。</p>
<h2 id="解题思路">解题思路</h2><p>我们可以考虑构建Tire树来存储给出的字符串，Tire树如下图所示：</p>
<p><img src="http://media.hihocoder.com/contests/hiho78/hiho78.png" alt=""></p>
<p>这样我们只用对树进行深度优先搜索，找到结点的值小于五就返回，用一个全局变量储存返回的次数即所求的前缀个数。</p>
<h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TireNode &#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;TireNode*&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> str, TireNode* &amp;head)</span> </span>&#123;</span><br><span class="line">	TireNode* p = head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">char</span> ch : str) &#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">auto</span> it = p-&gt;child.begin();</span><br><span class="line">		<span class="keyword">for</span> (; it != p-&gt;child.end(); ++it) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((*it)-&gt;ch == ch) &#123;</span><br><span class="line">				(*it)-&gt;cnt++;</span><br><span class="line">				p = (*it);</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">			TireNode* tmp = <span class="keyword">new</span> TireNode;</span><br><span class="line">			tmp-&gt;ch = ch;</span><br><span class="line">			tmp-&gt;cnt++;</span><br><span class="line">			p-&gt;child.push_back(tmp);</span><br><span class="line">			p = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TireNode* t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t-&gt;cnt &gt; <span class="number">5</span>) &#123;</span><br><span class="line">		<span class="keyword">auto</span> it = t-&gt;child.begin();</span><br><span class="line">		<span class="keyword">for</span> (; it != t-&gt;child.end(); ++it)</span><br><span class="line">			dfs(*it);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">string</span> tmp;</span><br><span class="line">	TireNode* t = <span class="keyword">new</span> TireNode;</span><br><span class="line">	t-&gt;cnt = <span class="number">6</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">		insert(tmp, t);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(t);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="hihoCoder第七十八周：Shortest_Proper_Prefix">hihoCoder第七十八周：Shortest Proper Prefix</h1><h2 id="题目">题目</h2><p>Query auto-completion(QAC) is]]>
    </summary>
    
      <category term="hiho" scheme="http://codle.net/tags/hiho/"/>
    
      <category term="算法" scheme="http://codle.net/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习" scheme="http://codle.net/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hihoCoder第七十二周：Disk Storage]]></title>
    <link href="http://codle.net/2015/11/16/hiho72/"/>
    <id>http://codle.net/2015/11/16/hiho72/</id>
    <published>2015-11-16T12:44:23.000Z</published>
    <updated>2015-11-16T12:59:50.559Z</updated>
    <content type="html"><![CDATA[<h1 id="hihoCoder第七十二周：Disk_Storage">hihoCoder第七十二周：Disk Storage</h1><h2 id="题目">题目</h2><p><img src="http://media.hihocoder.com//problem_images/20150103/14202824928356.png" alt=""></p>
<p>Little Hi and Little Ho have a disk storage. The storage’s shape is a truncated cone of height H. R+H is radius of top circle and R is radius of base circle.<br>Little Ho buys N disks today. Every disk is a cylinder of height 1. Little Ho wants to put these disk into the storage under below constraints:</p>
<ol>
<li>Every disk is placed horizontally. Its axis must coincide with the axis of storage.</li>
<li>Every disk is either place on the bottom surface or on another disk.</li>
<li>Between two neighboring disks in the storage, the upper one’s radius minus the lower one’s radius must be less than or equal to M.</li>
</ol>
<p>Little Ho wants to know how many disks he can put in the storage at most.</p>
<p>输入<br>Input contains only one testcase.<br>The first line contains 4 integers: N(1 &lt;= N &lt;= 100000), M, H, R(1 &lt;= M, R, H &lt;= 100000000).<br>The second line contains N integers, each number prepresenting the radius of a disk. Each radius is no more than 100000000.</p>
<p>输出<br>Output the maximum possible number of disks can be put into the storage.</p>
<p>样例输入<br>5 1 10 3<br>1 3 4 5 10<br>样例输出<br>4</p>
<h2 id="大意">大意</h2><p>在一个圆台中装圆形碟片，求问满足下面要求后最多能放几个圆碟：</p>
<ul>
<li>每个圆碟都放在中轴线上，每个圆碟都是挨着的</li>
<li>圆碟要么放在圆碟上要么放在水平面上</li>
<li>相邻两个圆碟，上面那个的半径减去下面那个的半径必须小于等于M</li>
</ul>
<h2 id="解题思路">解题思路</h2><p>上面那个减去下面那个半径小于等于M，并没有说是绝对值，因此从下到上假设摆成3-&gt;2-&gt;1这种也是满足要求的，因为都是负数小于M。因此解题思路就很明显了，先将圆碟按照半径排序，遍历直到有半径等于或者稍小于底面半径圆盘为止，显然之前已经被遍历的圆碟是一定能放的（只用按照从大到小的顺序摆在最上面即可），那么就从这个圆盘开始，依次查找满足M和R+H条件的圆盘即可。结果摆放如图所示：<br><img src="/imgs/hiho72.png" alt=""></p>
<h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, h, r;</span><br><span class="line">	<span class="keyword">int</span> num1, num2;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; h &gt;&gt; r;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">100001</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	sort(a, a + n);</span><br><span class="line">	num1 = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">if</span> (a[<span class="number">0</span>] &gt; r) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	num2 = num1;</span><br><span class="line">	cnt++;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; r + cnt)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[i] - num1 &gt; m)</span><br><span class="line">			<span class="keyword">if</span> (a[i] &lt;= r) &#123;</span><br><span class="line">				num2 = a[i];</span><br><span class="line">				num1 = num2;</span><br><span class="line">				cnt = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			num1 = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; min(i, h) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="hihoCoder第七十二周：Disk_Storage">hihoCoder第七十二周：Disk Storage</h1><h2 id="题目">题目</h2><p><img src="http://media.hihocoder.com//problem_ima]]>
    </summary>
    
      <category term="hiho" scheme="http://codle.net/tags/hiho/"/>
    
      <category term="算法" scheme="http://codle.net/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习" scheme="http://codle.net/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[动态规划]]></title>
    <link href="http://codle.net/2015/11/16/dp-pdf/"/>
    <id>http://codle.net/2015/11/16/dp-pdf/</id>
    <published>2015-11-16T07:10:32.000Z</published>
    <updated>2015-11-19T09:20:35.426Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文翻译自斯坦福大学的算法介绍课程PDF。英语水平不高，部分翻译可能比较生硬，还望见谅</p>
<h2 id="什么是动态规划">什么是动态规划</h2><blockquote>
<p>“通过将复杂问题分解为简单的子问题的方法” ————维基百科</p>
</blockquote>
<h2 id="动态规划的步骤">动态规划的步骤</h2><ol>
<li>定义子问题</li>
<li>找到子问题的递推关系</li>
<li>发现并解决每种基本情况</li>
</ol>
<h2 id="样例1:_区间型动态规划">样例1: 区间型动态规划</h2><h3 id="问题描述:">问题描述:</h3><p>给一个数n，求有多少种方案能通过1，3，4求和得到n？</p>
<h3 id="示例:">示例:</h3><p>对于一个数n = 5,答案是6<br>　５　＝　１　＋　１　＋　１　＋　１　＋　１<br>　　　＝　１　＋　１　＋　３<br>　　　＝　１　＋　３　＋　１<br>　　　＝　３　＋　１　＋　１<br>　　　＝　１　＋　４<br>　　　＝　４　＋　１</p>
<h3 id="定义子问题">定义子问题</h3><p>设$D_n$是用1,3,4求和得到n的方案总数</p>
<h3 id="找到子问题的递推关系">找到子问题的递推关系</h3><ul>
<li>思考一种可能的解决方案：n = $x_1 + x_2 + … + x_m$</li>
<li>如果$x_m$ = 1，那么剩下就需要求和至n-1</li>
<li>因此，以$x_m = 1$结尾的方案数量就等同于$D_{n-1}$ </li>
<li>对其他几种选择也使用上面的方法($x_m=3，x_m=4$)</li>
</ul>
<p>那么递推关系就出来:<br>$D_n = D_{n-1} + D_{n-3} + D_{n-4}$
　　</p>
<h3 id="解决基本情况">解决基本情况</h3><ul>
<li>$D_0 = 1$</li>
<li>$D_n = 0$ 用于初始化每个n的方案总数</li>
<li>当然，我们也可以设置：$D_0 = D_1 = D_2 = 1 且 D_3 = 2$</li>
</ul>
<h3 id="实现">实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D[<span class="number">0</span>] = D[<span class="number">1</span>] = D[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">D[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">4</span>; i &lt;= n; i++)</span><br><span class="line">    D[i] = D[i-<span class="number">1</span>] + D[i-<span class="number">3</span>] + D[i-<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<h2 id="例题:_POJ_2663:Tri_Tiling">例题: POJ 2663:Tri Tiling</h2><h3 id="问题描述:-1">问题描述:</h3><p>给一个数n，找出有多少种方案使用2 × 1的方块来填充3 × n的矩形</p>
<h3 id="示例：">示例：</h3><p>这里有一种填充n = 12的可行方案<br><img src="http://poj.org/images/2663_1.jpg" alt="&quot;n = 12&quot;"></p>
<h3 id="定义子问题-1">定义子问题</h3><p>设$D_n$是填充3 × n矩形的总方案数</p>
<h3 id="找出递推关系">找出递推关系</h3><p>很明显可以分析得出n为奇数时无法拼出矩形，那么下面都针对偶数的情况进行分析。<br>在n-2是拼好的情况下，要拼出n层的矩形有如下三种拼接方式。<br><img src="/imgs/dp001.png" alt=""></p>
<p>此时可以得出 $D_n = 3 × D_{n-2}$</p>
<p>但这只是解决了当第n-2是矩形的情况下的子问题。</p>
<p>那么当n-2不是矩形时能否让n层拼出矩形呢？<br>有如下两种方案可以实现：<br><img src="/imgs/dp002.png" alt=""></p>
<p>此时$D_n = ?$<br>$D_n = 3 × D_{n-2} + 2^{(n-2)/2}$?</p>
<p>这里显然不能把每个关节点想成是独立的问题来求幂运算，因为一旦一个关节开始按照方案来摆放，后面的摆放就已经是固定的了！不然无法完整的拼出一整个矩形。如下图：<br><img src="/imgs/dp003.png" alt=""><br>一旦按照黄色部分拼接，那么后面到n-2的地方都必须按照蓝色的方式进行拼接。<br>所以，正确的递推关系应该是:<br>$D_n = 3 × D_{n-2} + 2 × D_{n-4} + 2 × D_{n-6} + … + 2 × D_{0}$<br>我们对上式化简，左右同时减去$D_{n-2} = 3 × D_{n-4} + 2 × D_{n-6} + … + 2 × D_{0}$<br>得到：<br>$D_n - D_{n-2} = 3 × D_{n-2} - D_{n-4}$<br>$D_n = 4 × D_{n-2} - D_{n-4}$</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文翻译自斯坦福大学的算法介绍课程PDF。英语水平不高，部分翻译可能比较生硬，还望见谅</p>
<h2 id="什么是动态规划">什么是动态规划</h2><blockquote>
<p>“通过将复杂问题分解为简单的子问题的方法” ———]]>
    </summary>
    
      <category term="算法" scheme="http://codle.net/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习" scheme="http://codle.net/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法学习：回文串]]></title>
    <link href="http://codle.net/2015/11/03/ispalindrome/"/>
    <id>http://codle.net/2015/11/03/ispalindrome/</id>
    <published>2015-11-03T09:57:40.000Z</published>
    <updated>2015-11-12T07:22:26.808Z</updated>
    <content type="html"><![CDATA[<h1 id="算法学习：回文串">算法学习：回文串</h1><h2 id="前言">前言</h2><p>所谓回文串，就是从开头顺序读或者从结尾向前面读都一样的字符串（或链表），如abcdcba，madam。回文串能够轻易考验对字符串的应用，因此关于回文串的题目也是非常的广泛。</p>
<h2 id="判断回文">判断回文</h2><h3 id="题目描述">题目描述</h3><p>给定一个字符串，如何判断这个字符串是否是回文串。<br><img src="/imgs/algorithm.jpg" alt=""><br><a id="more"></a></p>
<h3 id="分析与解法：">分析与解法：</h3><h4 id="解法一：两头向中间扫">解法一：两头向中间扫</h4><p>找到这个字符串的开头和结尾，然后从两端开始向中间扫描，扫描过程中，如果对应的字符都相同，那么说明这个字符串回文。当前端超过或者等于后端时候结束扫描。<br>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!s.size())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> back = s.size() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (front &lt; back) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[front]!=s[back])</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		front++;</span><br><span class="line">		back--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度O(n),空间复杂度O(1)。</p>
<h4 id="解法二：中间向两头扫">解法二：中间向两头扫</h4><p>找到中间元素，然后向两端以此扫描查看是否相同，难点在于找到中点后的起点位置，字符串长度是奇数或者偶数是不同的。<br>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!s.size())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> n = s.size();</span><br><span class="line">	<span class="keyword">int</span> front, back;</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		front = n / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">		back = n / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		front = back = n / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (; front &gt;= <span class="number">0</span>; front--, back++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[front] != s[back])</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间空间复杂度和解法一相同，分别是O(n)和O(1)。</p>
<h2 id="链表判断回文">链表判断回文</h2><h3 id="题目描述-1">题目描述</h3><p>判断一条单向链表是不是回文</p>
<h3 id="分析与算法">分析与算法</h3><p>由于是单链表，单向传递无法使用两个指针来扫描。可以扫描一次找到中点，然后再来进行一次扫描，从开头和中点来开始扫描进行比较，但是这样扫描了两次会增加时间复杂度。我们这里考虑使用快慢指针的方法，用两个指针来开始扫描，一个指针每次递增一步，一个每次递增两步。当快的指针到达链表尾部是，慢的指针就到达了链表的中点。然后我们倒置后半段链表与开头进行比较判断是否是回文串。<br>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(Node* t)</span> </span>&#123;</span><br><span class="line">	Node* slow = t;</span><br><span class="line">	Node* flast = t;</span><br><span class="line">	Node* l = <span class="keyword">new</span> Node;</span><br><span class="line">	Node* p;</span><br><span class="line">	Node* tl;</span><br><span class="line">	<span class="keyword">while</span> (flast-&gt;next) &#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		flast = flast-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (flast-&gt;next)</span><br><span class="line">			flast = flast-&gt;next;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	p = slow;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">		Node* temp = <span class="keyword">new</span> Node(p-&gt;next-&gt;val);</span><br><span class="line">		temp-&gt;next = l-&gt;next;</span><br><span class="line">		l-&gt;next = temp;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (p = t-&gt;next, tl = l-&gt;next; tl != <span class="literal">NULL</span>; p = p-&gt;next, tl = tl-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val != tl-&gt;val)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[所谓回文串，就是从开头顺序读或者从结尾向前面读都一样的字符串（或链表），如abcdcba，madam。回文串能够轻易考验对字符串的应用，因此关于回文串的题目也是非常的广泛。]]>
    
    </summary>
    
      <category term="C++" scheme="http://codle.net/tags/C/"/>
    
      <category term="算法" scheme="http://codle.net/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习" scheme="http://codle.net/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构：二叉树（C++版）]]></title>
    <link href="http://codle.net/2015/10/29/binary-tree/"/>
    <id>http://codle.net/2015/10/29/binary-tree/</id>
    <published>2015-10-29T12:48:30.000Z</published>
    <updated>2015-11-12T07:27:20.202Z</updated>
    <content type="html"><![CDATA[<h1 id="数据结构：二叉树（C++版）">数据结构：二叉树（C++版）</h1><h2 id="二叉树的定义">二叉树的定义</h2><p>二叉树是每个节点最多有两个子树的树形结构，二叉树的子树有左右之分，其次序不能颠倒。<br>其中：</p>
<ul>
<li>二叉树第i层至多有2^(i-1)个节点（节点最多，则说明前面层都是满的，则每层都是上一层的两倍，第一层有2^0=1个节点）；</li>
<li>深度为k的二叉树至多有2^k-1个节点（即是说1-k层全满的情况，那么每层分别有2^0,2^1,2^2…2^(k-1)个节点，等比数列求和可得2^k-1）；</li>
</ul>
<p>一棵深度为k，且有2^k-1个节点称之为满二叉树；深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树。</p>
<p><img src="/imgs/useful.png" alt=""><br><a id="more"></a></p>
<h2 id="二叉树的储存">二叉树的储存</h2><h3 id="链式存储">链式存储</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">Node</span><span class="identifier"> </span><span class="title">&#123;  </span><br><span class="line">	ElemType</span> val;	//本结点储存值  </span><br><span class="line">	<span class="keyword">Node</span><span class="identifier"></span><span class="title">* left</span>;     //结点指针用于储存左子树  </span><br><span class="line">	<span class="keyword">Node</span><span class="identifier"></span><span class="title">* right</span>;	//结点指针用于储存右子树  </span><br><span class="line">        //构造函数，方便调用关键字new来构造节点  </span><br><span class="line">	<span class="keyword">Node</span><span class="identifier"></span><span class="title">(ElemType</span> v=<span class="number">0</span>) &#123;  </span><br><span class="line">		val = v;  </span><br><span class="line">		left = right = NULL;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>链式存储也是最常见的二叉树存储方式</p>
<h3 id="数组存储">数组存储</h3><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElemType <span class="keyword">val</span>[T];    <span class="comment">//T=2^k-1 k为二叉树深度</span></span><br></pre></td></tr></table></figure>
<p>数组的长度就是把当前二叉树当成满二叉树的情况下的结点数。假设一个父节点的下标序号是i，那么：</p>
<ul>
<li>左孩子的结点下标为i*2;</li>
<li>右孩子的结点下标为i*2+1;</li>
</ul>
<h2 id="二叉树的一些操作">二叉树的一些操作</h2><h3 id="二叉树的遍历">二叉树的遍历</h3><p>对于一个二叉树，遍历是最基本的操作，遍历二叉树即是说按照一定规则走完整个二叉树，使得每个结点被访问一次且只被访问一次。二叉树的遍历操作有：前序，中序，后序以及层序遍历。</p>
<h4 id="先序遍历">先序遍历</h4><p>先序遍历的遍历顺序是先访问根节点，然后访问左节点，最后访问右节点，算法实现如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> preOrderView(Node* T) &#123;		<span class="comment">//一个递归函数</span></span><br><span class="line">	<span class="comment">//当前判断当前结点是否为空，为空就回溯</span></span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		cout &lt;&lt; T<span class="subst">-&gt;</span>val &lt;&lt; <span class="string">" "</span>;	<span class="comment">//打印当前结点的值，即是访问根节点</span></span><br><span class="line">		preOrderView(T<span class="subst">-&gt;</span>left);	<span class="comment">//访问当前节点的左节点</span></span><br><span class="line">		preOrderView(T<span class="subst">-&gt;</span>right);	<span class="comment">//访问当前节点的右节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="中序遍历">中序遍历</h4><p>中序遍历的遍历顺序是左–&gt;根–&gt;右，算法与先序遍历基本一致:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> inOrdereView(Node* T) &#123;		<span class="comment">//一个递归函数</span></span><br><span class="line">	<span class="comment">//当前判断当前结点是否为空，为空就回溯</span></span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		inOrdereView(T<span class="subst">-&gt;</span>left);	<span class="comment">//访问当前节点的左节点</span></span><br><span class="line">		cout &lt;&lt; T<span class="subst">-&gt;</span>val &lt;&lt; <span class="string">" "</span>;	<span class="comment">//打印当前结点的值，即是访问根节点</span></span><br><span class="line">		inOrdereView(T<span class="subst">-&gt;</span>right);	<span class="comment">//访问当前节点的右节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="后序遍历">后序遍历</h4><p>后序遍历的遍历顺序是左–&gt;右–&gt;根，算法与上述两个基本相同:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> postOrdereView(Node* T) &#123;			<span class="comment">//一个递归函数</span></span><br><span class="line">	<span class="comment">//当前判断当前结点是否为空，为空就回溯</span></span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		postOrdereView(T<span class="subst">-&gt;</span>left);	<span class="comment">//访问当前节点的左节点</span></span><br><span class="line">		postOrdereView(T<span class="subst">-&gt;</span>right);	<span class="comment">//访问当前节点的右节点</span></span><br><span class="line">		cout &lt;&lt; T<span class="subst">-&gt;</span>val &lt;&lt; <span class="string">" "</span>;		<span class="comment">//打印当前结点的值，即是访问根节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="层序遍历">层序遍历</h4><p>不同于上述三种遍历，层序遍历即是一层一层的访问二叉树的节点，使用的算法思想是广度优先搜索，使用辅助队列来存储每一层的节点。算法实现如下:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> levelOrderView(Node* T) &#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;Node*&gt; q;				<span class="comment">//声明一个队列，这里使用了STL,也可以自己写</span></span><br><span class="line">	Node* t;				<span class="comment">//存取队列元素</span></span><br><span class="line">	q<span class="built_in">.</span>push(T);				<span class="comment">//把根节点放入队列</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="subst">!</span>q<span class="built_in">.</span>empty()) &#123;			<span class="comment">//当队列不为空的时候执行循环</span></span><br><span class="line">		t = q<span class="built_in">.</span>front();			<span class="comment">//t取队头元素</span></span><br><span class="line">		<span class="keyword">if</span> (t<span class="subst">-&gt;</span>left)			<span class="comment">//如果t的左孩子不为空，那么放入队列中</span></span><br><span class="line">			q<span class="built_in">.</span>push(t<span class="subst">-&gt;</span>left);</span><br><span class="line">		<span class="keyword">if</span> (t<span class="subst">-&gt;</span>right)			<span class="comment">//同上</span></span><br><span class="line">			q<span class="built_in">.</span>push(t<span class="subst">-&gt;</span>right);</span><br><span class="line">		q<span class="built_in">.</span>pop();			<span class="comment">//抛出队头元素</span></span><br><span class="line">		cout &lt;&lt; t<span class="subst">-&gt;</span>val &lt;&lt; <span class="string">" "</span>;		<span class="comment">//打印队头元素的值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="通过遍历结果建树">通过遍历结果建树</h3><p>前面我们讲述了三种基本的遍历二叉树方法（前序，中序，后序遍历），那么下面我们将讲述如何通过前序和中序序列或者后序和中序序列来构建这颗二叉树。</p>
<h4 id="前序和中序序列建树">前序和中序序列建树</h4><p>在前序遍历中，遍历二叉树的顺序是根–&gt;左–&gt;右的顺序，而在中序遍历中，遍历顺序是左–&gt;根–&gt;右的顺序。在两者生成的遍历序列中，我们可以很快发现，前序遍历的第一个元素就是该二叉树的根节点，然后再去中序遍历中找到这个元素，因为中序是左–&gt;根–&gt;右的遍历顺序，那么在根节点左侧的字符串就是该根节点的左子树，右侧的字符串就是该节点的右子树。那么对子树，我们有可以从前序遍历中找到相应根节点然后重复做上述步骤，这样就完成了一棵二叉树的建立。由于步骤是一个重复的过程，我们可以使用递归的方式来进行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="built_in">string</span> inOrder, <span class="built_in">string</span> preOrder, Node* &amp;t)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> inL, inR, preL, preR;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;                      <span class="comment">//标志变量用于判断是否找到根节点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inOrder.size(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inOrder[i] == preOrder[<span class="number">0</span>]) &#123;    <span class="comment">//查找根节点</span></span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;              	<span class="comment">//在没找到根节点时，把遍历的字符串放入左子树串</span></span><br><span class="line">			inL.push_back(inOrder[i]);</span><br><span class="line">			preL.push_back(preOrder[i + <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;                              	<span class="comment">//找到了后就放入右子树串</span></span><br><span class="line">			inR.push_back(inOrder[i]);</span><br><span class="line">			preR.push_back(preOrder[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;val = preOrder[<span class="number">0</span>];                   <span class="comment">//把当前根值赋给根节点</span></span><br><span class="line">	<span class="keyword">if</span> (inL.size()) &#123;                       <span class="comment">//如果左子树串不为空，那么递归调用，对左子树进行构树</span></span><br><span class="line">		t-&gt;left = <span class="keyword">new</span> Node;</span><br><span class="line">		buildTree(inL, preL, t-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (inR.size()) &#123;                       <span class="comment">//如果右子树串不空，就对右子树构树。</span></span><br><span class="line">		t-&gt;right = <span class="keyword">new</span> Node;</span><br><span class="line">		buildTree(inR, preR, t-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="后序和中序序列建树">后序和中序序列建树</h4><p>后序和中序序列建树的方法大致思路相同，只是在寻找根节点的方法不同，因为后序遍历的顺序是左–&gt;右–&gt;根，所以后序遍历的最后一个元素是根节点，和前序遍历的首元素不同。其他思路可以参考上文，下面是代码的实现:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree2</span><span class="params">(<span class="built_in">string</span> inOrder, <span class="built_in">string</span> postOrder, Node* &amp;t)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> inL, inR, postL, postR;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inOrder.size(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inOrder[i] == postOrder[postOrder.size() - <span class="number">1</span>]) &#123;</span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">			inL.push_back(inOrder[i]);</span><br><span class="line">			postL.push_back(postOrder[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			inR.push_back(inOrder[i]);</span><br><span class="line">			postR.push_back(postOrder[i - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;val = postOrder[postOrder.size() - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (inL.size()) &#123;</span><br><span class="line">		t-&gt;left = <span class="keyword">new</span> Node;</span><br><span class="line">		buildTree2(inL, postL, t-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (inR.size()) &#123;</span><br><span class="line">		t-&gt;right = <span class="keyword">new</span> Node;</span><br><span class="line">		buildTree2(inR, postR, t-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[树是一种非常重要的数据结构，树形结构在计算机科学中应用的非常广泛，二叉树是一种特殊的树形结构。本文将讲解数据结构中二叉树的实现及一些在实际应用中的算法实现。]]>
    
    </summary>
    
      <category term="C++" scheme="http://codle.net/tags/C/"/>
    
      <category term="数据结构" scheme="http://codle.net/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构" scheme="http://codle.net/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用hexo搭建个人博客]]></title>
    <link href="http://codle.net/2015/10/29/how-to-build-hexo/"/>
    <id>http://codle.net/2015/10/29/how-to-build-hexo/</id>
    <published>2015-10-29T07:08:54.000Z</published>
    <updated>2015-11-12T07:18:35.678Z</updated>
    <content type="html"><![CDATA[<h1 id="使用hexo搭建个人博客">使用hexo搭建个人博客</h1><h2 id="前言">前言</h2><p>折腾了两天终于做好了这个博客站，相比于wordpress+虚拟空间的组合，使用Github Page+hexo无疑显得要更加轻便与稳定。<br>下面就来谈一谈是如何在Github上搭建一个hexo博客的。</p>
<p><img src="/imgs/post1.jpg" alt="&quot;Hexo&quot;"></p>
<a id="more"></a>
<h2 id="搭建环境">搭建环境</h2><p>hexo是一个基于node.js的静态博客框架，因此电脑需要安装node.js环境，同时也需要Git软件用于上传博客文件</p>
<ul>
<li><a href="http://nodejs.org" target="_blank" rel="external">Node.js</a></li>
<li><a href="http://git-scm.com/" target="_blank" rel="external">Git</a></li>
</ul>
<h2 id="注册GitHub">注册GitHub</h2><p>访问<a href="http://www.github.com/" target="_blank" rel="external">GitHub</a>官网注册一个账号。</p>
<p>邮箱请确保能收到消息，GitHub上的消息都是通过邮件通知的。</p>
<h2 id="配置和使用GitHub">配置和使用GitHub</h2><p>在注册完GitHub后，进行一些必要的SSH配置，以确保本地Git项目能与远程的Github联系。</p>
<h3 id="检查SSH_Keys">检查SSH Keys</h3><p>首先检查电脑上现有的SSH Keys，打开之前安装的Git Bash，输入：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh &#26816;&#26597;&#26412;&#26426;ssh&#23494;&#38053;</span><br></pre></td></tr></table></figure></p>
<p>如果提示: No such file or directory 说明是第一次使用git。</p>
<h3 id="生成新的SSH_Key：">生成新的SSH Key：</h3><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"邮件地址@youremail.com"</span></span><br><span class="line">Generating <span class="keyword">public</span>/<span class="keyword">private</span> rsa <span class="keyword">key</span> pair.</span><br><span class="line">Enter file <span class="keyword">in</span> which <span class="keyword">to</span> save the <span class="keyword">key</span> (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>邮件地址填入你自己的邮箱地址</li>
<li>-C是大写的C，且每个-前面都是有一个空格的</li>
</ul>
<p>然后系统会要求你创建密码：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):<span class="variable">&lt;输入加密串&gt;</span></span><br><span class="line">Enter same passphrase again:<span class="variable">&lt;再次输入加密串&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这个密码在你之后提交项目时使用，如果为空的话在提交项目时可以不输入。这是为了防止别人在你的项目里面提交文件。</p>
<p>注意：输入密码时候不会显示字符或者*，直接输完回车即可。</p>
<p>看到显示一个方框图形就表示成功设置SSH Key了。</p>
<h3 id="添加SSH_Key到GitHub">添加SSH Key到GitHub</h3><p>本机设置SSH Key后，需要添加到GitHub上，已完成SSH链接的设置。</p>
<ol>
<li>用记事本打开本地C:\Users\用户名.ssh\id_rsa.pub文件。这个文件里面内容是刚刚生成的密钥。如果看不到文件，你需要设置显示隐藏文件。ctrl+a复制全部文本。</li>
<li>登陆github。点击右上角头像Settings-&gt;SSH Keys-&gt;Add SSH Key。title可以随便取名，把刚才复制的内容粘贴进Key里面去。</li>
<li>点击Add Key完成设置。</li>
</ol>
<h3 id="测试SSH_Key">测试SSH Key</h3><p>输入下面的命令，看看设置是否成功，请勿改动命令内容:<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh -<span class="constant">T</span> git<span class="variable">@github</span>.com</span><br></pre></td></tr></table></figure></p>
<p>会出现如下内容:<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity <span class="keyword">of</span> host <span class="comment">'github.com (207.97.227.239)' can't be established.</span></span><br><span class="line">RSA <span class="keyword">key</span> fingerprint <span class="keyword">is</span> <span class="number">16</span>:<span class="number">27</span>:ac:a5:<span class="number">76</span>:<span class="number">28</span>:<span class="number">2</span>d:<span class="number">36</span>:<span class="number">63</span>:<span class="number">1</span>b:<span class="number">56</span>:<span class="number">4</span>d:eb:df:a6:<span class="number">48.</span></span><br><span class="line">Are you sure you want <span class="keyword">to</span> <span class="keyword">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure></p>
<p>输入yes即可，如果之前设置了SSH Key密码，那么还会要求输入之前的密码<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi user! You've successfully authenticated, <span class="keyword">but</span> GitHub <span class="keyword">does</span> <span class="keyword">not</span> provide shell access.</span><br></pre></td></tr></table></figure></p>
<h3 id="设置用户信息">设置用户信息</h3><p>Git通过用户的名字和邮箱来上传文件，输入下面的代码进行个人信息的设置。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user<span class="class">.name</span> <span class="string">"user"</span><span class="comment">//用户名</span></span><br><span class="line">$ git config --global user<span class="class">.email</span>  <span class="string">"user@gmail.com"</span><span class="comment">//填写自己的邮箱</span></span><br></pre></td></tr></table></figure></p>
<h3 id="SSH_Key配置成功">SSH Key配置成功</h3><p>如果中途出现问题，请按照步骤从头再来一次。</p>
<h2 id="使用GitHub_Page建立博客">使用GitHub Page建立博客</h2><p>GitHub Page是GitHub提供给每个用户的一个功能。可以通过username.github.io的方式进行访问，每个用户名下只能创建一个。</p>
<h3 id="建立仓库">建立仓库</h3><p>登陆GitHub，点击 New Repository 填写项目信息。</p>
<ul>
<li>project name ：username.github.io</li>
<li>description :填写项目描述，可以不写</li>
</ul>
<p>注意：username一定是你的Github名字。</p>
<h2 id="使用hexo">使用hexo</h2><h3 id="安装">安装</h3><p>打开Git Bash，运行下面的命令：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> hexo</span></span><br></pre></td></tr></table></figure></p>
<p>自己在磁盘中建一个名为hexo的文件夹，在Git Bash中使用cd命令进入hexo文件夹下，运行下面的命令:<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo init</span><br></pre></td></tr></table></figure></p>
<p>就完成了hexo的本地博客安装。</p>
<h3 id="本地浏览">本地浏览</h3><p>我们可以通过下面的命令在本地查看博客：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo s</span><br></pre></td></tr></table></figure></p>
<p>在浏览器输入 localhost:4000 查看。</p>
<h3 id="_config-yml文件">_config.yml文件</h3><p>hexo文件根目录下的_config.yml存储了一些关于博客的基础设置，可以自己查看酌情修改。而theme里面的主题文件对应的_config.yml则是修改主题设置的。</p>
<h3 id="上载自己的博客程序">上载自己的博客程序</h3><p>部署到GitHub前需要配置根目录下的_config.yml文件。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">    <span class="attribute">type</span>: github</span><br><span class="line">    <span class="attribute">repository</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:username/username.github.com.git</span><br><span class="line">    <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></p>
<p>之后执行下列指令即可完成部署:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="keyword">g</span></span><br><span class="line">hexo <span class="literal">d</span></span><br></pre></td></tr></table></figure></p>
<p>也可以直接输入：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="keyword">d</span> -<span class="keyword">g</span></span><br></pre></td></tr></table></figure></p>
<p>即完成了博客的上传。上传完成后就可以通过username.github.io访问你的博客了。</p>
<h2 id="DNS解析">DNS解析</h2><p>如何将博客解析到自己的域名上？可以通过如下设置完成：<br>添加两条A记录:</p>
<ul>
<li>192.30.252.153</li>
<li>192.30.252.154</li>
</ul>
<p>在hexo\sourcex下新建记事本，写上自己的域名，然后改名为CNAME(注意没有后缀名)，然后上载博客。<br>在域名管理中添加CNAME解析，主机记录添加wwww,记录值改为 username.github.io 。</p>
<h2 id="后记">后记</h2><p>感谢各位大大提供的教程:</p>
<ul>
<li><a href="http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></li>
<li><a href="http://yangjian.me/workspace/building-blog-with-hexo/" target="_blank" rel="external">使用hexo搭建博客</a></li>
</ul>
<p>附上需要的链接：</p>
<ul>
<li><a href="https://hexo.io/" target="_blank" rel="external">Hexo官网（是台湾前辈开发的，因此很多文档都带有繁中）</a></li>
<li><a href="https://hexo.io/" target="_blank" rel="external">GitHub Page（如果Ip无法解析了，请及时来看）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[折腾了两天终于做好了这个博客站，相比于wordpress+虚拟空间的组合，使用Github Page+hexo无疑显得要更加轻便与稳定。下面就来谈一谈是如何在Github上搭建一个hexo博客的。]]>
    
    </summary>
    
      <category term="blog" scheme="http://codle.net/tags/blog/"/>
    
      <category term="hexo" scheme="http://codle.net/tags/hexo/"/>
    
      <category term="博客相关" scheme="http://codle.net/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
</feed>
