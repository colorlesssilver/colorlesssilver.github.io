<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Codle]]></title>
  <subtitle><![CDATA[无比芜杂的心绪]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://codle.net/"/>
  <updated>2016-08-02T12:42:31.370Z</updated>
  <id>http://codle.net/</id>
  
  <author>
    <name><![CDATA[Silver]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[机器学习日志：Logistic 回归]]></title>
    <link href="http://codle.net/2016/08/02/logistic-regression/"/>
    <id>http://codle.net/2016/08/02/logistic-regression/</id>
    <published>2016-08-02T12:27:46.000Z</published>
    <updated>2016-08-02T12:42:31.370Z</updated>
    <content type="html"><![CDATA[<h2 id="Logistic回归">Logistic回归</h2><p>Logistic回归(《统计学习方法》中译为逻辑斯谛回归），虽然也是回归模型，但是与线性回归模型不同，Logistic回归通过训练数据集来对数据集建立边界用于数据分类，因此主要用于分类器。<br>对于Logistic回归，我们的预测函数不再是根据特征来输出一个数据值了，而是分类的类别，比如结果类别只有两个，那么我们通过预测函数的输出值就应该是0,1。具有这种性质的函数被称为阶跃函数，瞬间阶跃可能比较难处理，我们引入另一个具有类似性质的函数Sigmoid函数。Sigmoid函数的具体计算公式如下：<br>$$\sigma(z)=\frac1{1+e^{-z}}$$<br>当$z=0$时，$\sigma(z)=0.5$，当$z$值增大时，$\sigma(z)$值逼近于$1$，随着$z$减少时，$\sigma(z)$值逼近0。如果横坐标刻度足够大，那么Sigmoid函数看起来就像阶跃函数。</p>
<h2 id="Logistic回归模型">Logistic回归模型</h2><h3 id="模型">模型</h3><p>二项Logistic回归模型是一种分类模型，由条件概率分布$P(Y|X)$表示，形式为参数化的Logistic分布。条件概率为：<br>$$P(Y=1|x)=\frac1{1+e^{-w\cdot x}} \\P(Y=0|x)=\frac{e^{-w\cdot x}}{1+e^{-w\cdot x}}$$<br>$x\in R^n$为输入特征值，$Y\in {0,1}$是输出值，$w\in R^n$是权值参数。对于给定的输入实例$x$，Logistic回归通过比较两个条件概率值的大小来分配实例$x$到概率较大的那一类中。</p>
<h3 id="特点">特点</h3><p>一个事件的几率(odds,the odds of experiencing an event)是指该事件发生的概率与该事件不发生的概率的比值。如果事件发生的概率为$p$，那么该事件的几率为$\frac{p}{1-p}$，该事件的对数几率（log odds）是<br>$$logit(p)=log\frac{p}{1-p}$$<br>那么针对Logistic回归，对数几率就为：<br>$$log\frac{P(Y=1|x)}{1-P(Y=1|x)}=w\cdot x$$<br>这就表示在Logistic回归模型中，输出$Y=1$的对数几率是输入$x$的线性函数。</p>
<h2 id="模型参数估计">模型参数估计</h2><p>Logistic回归模型学习时，对于给定的训练集$T = \{(x_1,y_1),(x_2,y_2),\cdots,(x_n,y_n)\}$，可以采用极大似然估计法来估计模型参数。<br>设：$ P(Y=1|x)=\pi(x),P(Y=0|x)=1-\pi(x)$<br>似然函数为：<br>$$\prod_{i=1}^n[\pi(x_i)]^{y_i}[1-\pi(x_i)]^{1-y_i}$$<br>对数似然函数为：<br>$$L(w)=\sum_{i=1}^n[y_ilog(\pi(x_i))+(1-y_i)log(1-\pi(x_i))]$$<br>对$L(w)$求取极大值，就能得到$w$的极大似然估计。用大学《概率统计》所学的就是求<br>$$\frac{\partial L(w)}{\partial w}=0$$<br>时的$w$的值就是w的极大似然估计$\hat w$<br>由于方程比较复杂无法直接进行求偏导运算，因此考虑迭代法来求取近似值，一般使用梯度下降法和拟牛顿法。</p>
<h2 id="Logistic回归实战（Python）">Logistic回归实战（Python）</h2><p>首先我们从文本中读取出数据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">()</span>:</span></span><br><span class="line">    X = []; y = []</span><br><span class="line">    fr = open(<span class="string">'./Tests/ex2data2.txt'</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> fr.readlines():</span><br><span class="line">        line_arr = line.strip().split(<span class="string">','</span>)</span><br><span class="line">        X.append([<span class="number">1.0</span>, float(line_arr[<span class="number">0</span>]), float(line_arr[<span class="number">1</span>])])</span><br><span class="line">        y.append(float(line_arr[-<span class="number">1</span>]))</span><br><span class="line">    fr.close()</span><br><span class="line">    X = array(X)</span><br><span class="line">    y = array(y)</span><br><span class="line">    <span class="keyword">return</span> X, y</span><br></pre></td></tr></table></figure></p>
<p>我们使用matplotlab.pyplot库来打印图形，我们先把刚刚的数据图形化打印出来<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_data</span><span class="params">(X, y)</span>:</span></span><br><span class="line">    m = shape(X)[<span class="number">0</span>]</span><br><span class="line">    xcord1 = []; ycord1 = []</span><br><span class="line">    xcord2 = []; ycord2 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">        <span class="keyword">if</span> int(y[i]) == <span class="number">1</span>:</span><br><span class="line">            xcord1.append(X[i, <span class="number">1</span>])</span><br><span class="line">            ycord1.append(X[i, <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            xcord2.append(X[i, <span class="number">1</span>])</span><br><span class="line">            ycord2.append(X[i, <span class="number">2</span>])</span><br><span class="line">    fig = plt.figure()</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax.scatter(xcord1, ycord1, s=<span class="number">30</span>, c=<span class="string">'red'</span>, marker=<span class="string">'s'</span>)</span><br><span class="line">    ax.scatter(xcord2, ycord2, s=<span class="number">30</span>, c=<span class="string">'green'</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'X1'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'X2'</span>)</span><br></pre></td></tr></table></figure></p>
<p>我们得到下面这张图:<br><img src="http://codle.net/imgs/machine-learning/03-01.png" alt=""></p>
<p>Sigmoid函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(inx)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1</span>+exp(-inx))</span><br></pre></td></tr></table></figure></p>
<p>本来我们只有两个特征量$x_1，x_2$，但仅仅两个特征量只能拟合出一条直线，因此我们需要使用特征量的不同幂来拓展特征量，比如$x_1x_2,x_1^2,x_2^2,x_1^2x_2\cdots$，可以写成循环形式，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map_feature</span><span class="params">(x1, x2)</span>:</span></span><br><span class="line">    out = ones((shape(x1)[<span class="number">0</span>], <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">7</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, i+<span class="number">1</span>):</span><br><span class="line">            temp = (x1**(i-j))*(x2**j)</span><br><span class="line">            out = column_stack((out, reshape(temp, len(temp))))</span><br><span class="line">    <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure></p>
<p>一个简单的梯度上升算法，没有正则化，但对这次的题目影响不大，梯度算法可以参考上一篇文章:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grad_ascent</span><span class="params">(data_mat_in, class_labels)</span>:</span></span><br><span class="line">    data_mat = mat(data_mat_in)</span><br><span class="line">    label_mat = mat(class_labels).transpose()</span><br><span class="line">    m, n = shape(data_mat)</span><br><span class="line">    alpha = <span class="number">0.001</span></span><br><span class="line">    max_cycle = <span class="number">3000</span></span><br><span class="line">    theta = ones([n, <span class="number">1</span>])</span><br><span class="line">    theta = mat(theta)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(max_cycle):</span><br><span class="line">        h = sigmoid(data_mat*theta)</span><br><span class="line">        error = (label_mat - h)</span><br><span class="line">        theta += alpha*data_mat.transpose()*error</span><br><span class="line">    <span class="keyword">return</span> theta</span><br></pre></td></tr></table></figure></p>
<p>我们将拟合出来的权值$w$做成函数曲线打印出来:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_fit</span><span class="params">(theta, X, y)</span>:</span></span><br><span class="line">    plot_data(X[:, <span class="number">0</span>:<span class="number">3</span>], y)</span><br><span class="line">    u = linspace(-<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">50</span>)</span><br><span class="line">    v = linspace(-<span class="number">1</span>, <span class="number">1.5</span>, <span class="number">50</span>)</span><br><span class="line">    z = zeros((len(u), len(v)))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(u)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(v)):</span><br><span class="line">            z[i, j] = mat(map_feature(array([u[i]]), array([u[j]])))*mat(theta)</span><br><span class="line">    z = z.transpose()</span><br><span class="line">    plt.contour(u, v, z, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>打印出来的效果如下图所示，可以看出曲线基本拟合了我们的训练数据集<br><img src="http://codle.net/imgs/machine-learning/03-02.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="Logistic回归">Logistic回归</h2><p>Logistic回归(《统计学习方法》中译为逻辑斯谛回归），虽然也是回归模型，但是与线性回归模型不同，Logistic回归通过训练数据集来对数据集建立边界用于数据分类，因此主要用于分类器。<br>对于Lo]]>
    </summary>
    
      <category term="机器学习" scheme="http://codle.net/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习日志：线性回归]]></title>
    <link href="http://codle.net/2016/07/14/linear-regression/"/>
    <id>http://codle.net/2016/07/14/linear-regression/</id>
    <published>2016-07-14T11:24:48.000Z</published>
    <updated>2016-07-19T08:44:33.528Z</updated>
    <content type="html"><![CDATA[<h2 id="线性回归模型">线性回归模型</h2><p>线性回归模型属于监督学习的一种，给定训练数据集，通过’学习’找出一个较精确的函数$h$来描述输入X和输出Y之间的关系，进而完成’预测’的功能，比如房屋价格预测。<br>对于一个输入变量x和一个输出变量y，可以用这样一个函数$h_\theta(x) = \theta_0 + \theta_1x$来表达，我们可以很容易地得出一个更一般的表达（即并不一定只有一个输入变量x的情况）:<br>$$h_\theta(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + \theta_3x_3 + \cdots$$<br>我们将单个输入量的情况叫做一元线性回归，多个输入量的叫做多元线性回归。</p>
<h2 id="$\theta$参数求解">$\theta$参数求解</h2><p>对于线性回归模型，我们的最终目的是要得到一个较精确的$h_\theta(x)$函数来表示输入和输出的关系，因此，我们的工作目的就是算出合适的$\theta$参数，来使得我们的函数曲线与数据点集尽可能地耦合。</p>
<h3 id="梯度下降法">梯度下降法</h3><h4 id="概念">概念</h4><p>这里使用梯度下降(Gradient Descent)的方法来求解参数$\theta$。梯度下降是求解无约束最优化问题的一种最常用的方法。从直观上理解就好似我们站在山顶(初始点)，希望能最快的地走到山脚(最优解)，那么我们通过每次向四周找寻一个方向（最陡的方向）走一步，找一个方向，再走一步，这样一次又一次地走到山脚。通过这样的描述很容易看出梯度下降的使用问题：可能会陷于局部最优解而无法获得全局最优解(就是说掉坑里了,HOHO)，但是对于凸函数是能求得最优解的。<br>从专业术语来描述梯度下降法就是:选取使得初始值$x^{(0)}$，不断迭代，更新$x$的值，进行目标函数的极小化，直到收敛。由于负梯度方向是使函数值下降最快的方向，在迭代的每一步，以负梯度方向更新$x$的值，从而达到减少函数值的目的。</p>
<h4 id="算法步骤">算法步骤</h4><p>在这里我们引入代价函数$J(\theta)$的概念，直观上理解可以当成从山顶到山底所需要的消耗，我们希望这个消耗尽可能地小。因此线性回归模型就是通过学习函数$h(x)$使得代价函数$J(\theta)$最小。<br>算法的步骤大致就是这样的:</p>
<ul>
<li>计算代价函数值$J(\theta)$</li>
<li>迭代更新$\theta$</li>
</ul>
<p>重复上面的操作，直到$J(\theta)$收敛的时候(可以采用画图的方法)，我们也就得到了一个较为准确的$\theta$参数。</p>
<h4 id="代价函数$J(\theta)$">代价函数$J(\theta)$</h4><p>在线性回归中，我们使用最小二乘法的方法来当作我们的代价函数$J(\theta)$。<br>$$J(\theta) = \frac1{2m}\sum_{i=1}^m(h_\theta(x^{(i)}) - y^{(i)})^2$$<br>注：<br>$$h_\theta(x) = \theta_0 + \theta_1x_1 + \theta_2x_2 + \theta_3x_3 + \cdots = \begin{bmatrix}1 &amp; x_1 &amp; x_2 \cdots &amp; x_n\end{bmatrix} \begin{bmatrix}\theta_0 \\ \theta_1 \\ \vdots \\ \theta_n\end{bmatrix}$$</p>
<h4 id="更新参数$\theta$">更新参数$\theta$</h4><p>下降最快的方向是负梯度的方向，很容易写出:<br>$$\theta := \theta - \nabla J(\theta)$$<br>注意这里的$\theta = \begin{bmatrix}\theta_0&amp;\theta_1&amp;\theta_2&amp;\cdots&amp;\theta_n\end{bmatrix}^T$，这个公式涉及到偏导数，在进行具体实现时，我们通常转化为下面这个公式进行求解:<br>$$\theta_j := \theta_j - \alpha\frac1{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}$$<br>这个分别对每个$\theta$进行求解，但是在计算的时候需要注意一定<strong>要用原始的$\theta$算完所有的$\theta$后再进行参数更新！</strong></p>
<p>在实战中，对于$x = \begin{bmatrix} \cdots &amp; x^{(0)} &amp; \cdots \\ \cdots &amp; x^{(1)}&amp; \cdots \\ \cdots &amp;\cdots&amp;\cdots \\ \cdots &amp; x^{(n)}&amp;\cdots \end{bmatrix} y = \begin{bmatrix}y^{(0)}\\y^{(1)}\\ \vdots \\ x^{(n)}\end{bmatrix} \theta = \begin{bmatrix} \theta_0\\ \theta_1 \\ \vdots \\ \theta_n \end{bmatrix}$,这个公式也可以写成：<br>$$\theta := \theta - \alpha\frac1{m}(x^T(x\theta-y))$$</p>
<h4 id="特征正则化">特征正则化</h4><p>这一步实际应该在所有步骤之前，主要用于将特征量$x$缩放至一个相对合适的大小（一般在$\pm2$之间），防止过拟合等状况出现。举个例子，也就说你一个特征量是3000左右，另一个却在0.2左右，这样算法在计算的时候很容易出现之字形下降，耗费额外的迭代次数却很难找到合适的参数。<br>常用的正则化方法为:<br>$$ x’ = \frac{x - \overline{x}}{\delta}$$<br>$\overline{x}$是特征平均值；$\delta$是特征标准差，也可以用$max-min$替代。</p>
<h3 id="正规方程法（Normal_Equation）">正规方程法（Normal Equation）</h3><p>这里在讲一种用于解决线性回归问题的方法，叫做正规方程法。用解方程的形式来进行求解参数$\theta$，公式非常简明:<br>$$\theta = (X^TX)^{-1}X^T\vec{y}$$<br>这个方程看似简单，但是缺点却很明显：涉及对矩阵求逆。矩阵逆运算的时间复杂度为$O(n^3)$，当特征很多的时候运行效率会非常缓慢。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="线性回归模型">线性回归模型</h2><p>线性回归模型属于监督学习的一种，给定训练数据集，通过’学习’找出一个较精确的函数$h$来描述输入X和输出Y之间的关系，进而完成’预测’的功能，比如房屋价格预测。<br>对于一个输入变量x和一个输出变量y，可以用这样一个函]]>
    </summary>
    
      <category term="机器学习" scheme="http://codle.net/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="线性回归" scheme="http://codle.net/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[机器学习日志：介绍]]></title>
    <link href="http://codle.net/2016/03/31/machine-learning-introduction/"/>
    <id>http://codle.net/2016/03/31/machine-learning-introduction/</id>
    <published>2016-03-31T02:11:15.000Z</published>
    <updated>2016-07-05T08:55:21.332Z</updated>
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近开始学习C站上的NG的机器学习课程，会把视频中的内容写成笔记方便查阅，待学完后会将全部的笔记整理成PDF。</p>
<h1 id="监督学习（Supervised_Learning）">监督学习（Supervised Learning）</h1><h2 id="示例1:预测房价">示例1:预测房价</h2><p>为了预测房价，某同学收集了某地区的房价数据集（如图），假设你朋友有栋750尺的房子，想知道房子在什么价格好卖掉。</p>
<p><img src="/imgs/machine-learning/01-01.png" alt=""></p>
<p>学习算法可以提供一些用于估计房子价格的方法，比如使用直线函数，或者使用平方函数等等方法来进行拟合。下图给出了两种不同函数拟合后估计的结果。</p>
<p><img src="/imgs/machine-learning/01-02.png" alt=""></p>
<h2 id="定义:监督学习">定义:监督学习</h2><p>监督学习，意在给定一个算法，需要部分数据集已有正确答案。比如给定房价数据集，对于里面的每个数据，算法都知道对应的正确房价，即房子的实际卖出价格。算法的结果就是算出更多正确的价格，比如那个新房子，你朋友想卖的那个。</p>
<h2 id="定义:回归问题">定义:回归问题</h2><p>回归问题属于监督学习，意在预测一个连续值的输出，比如价格，意味着要预测这类连续值属性的种类。</p>
<h2 id="示例2:肿瘤问题">示例2:肿瘤问题</h2><p>预测胸部肿瘤是良性还是恶性，下面是一个已知数据集，横轴代表肿瘤大小，纵轴用1表示恶性，0表示良性。</p>
<p><img src="/imgs/machine-learning/01-03.png" alt=""></p>
<p>现在假设一个人得了肿瘤，其大小是图中的品红箭头位置，现在希望能估算出肿瘤是良性还是恶性的概率。</p>
<h2 id="定义:分类问题">定义:分类问题</h2><p>分类问题被用于预测离散值的输出，比如肿瘤问题，其结果要么为良性，要么为恶性，这是一个离散的数据。数据集需要有一定的特征量，在肿瘤问题中有一个特征量肿瘤大小，在实际中特征量的个数并没有限制，对于无限多的特征量，需要后文的支持向量机的算法来解决。</p>
<h1 id="无监督学习（Unsupervised_Learning）">无监督学习（Unsupervised Learning）</h1><h2 id="定义:无监督学习">定义:无监督学习</h2><p>对于监督学习的每个样本，我们都事先地告诉了每个样本所谓的正确答案（即样本数据集），在无监督学习中，我们没有属性或者标签这个概念，也就是说所有数据看起来都是一样的，如下图所示，左图为监督学习，右图为无监督学习。</p>
<p><img src="/imgs/machine-learning/01-04.png" alt=""></p>
<p>在无监督学习中，没人告诉我们数据如何使用，每个数据点究竟是什么意思，它只告诉我们现在有一个数据集，需要我们找出数据间的结构。对于一个数据集，无监督学习算法能判断该数据集包含的不同聚类，也就是所谓的聚类算法。</p>
<h2 id="示例:实际运用场景">示例:实际运用场景</h2><p>1.在Google新闻中，自动地将不同媒体的关于同一事件的新闻报告的URL聚集到同一标题下。</p>
<p><img src="/imgs/machine-learning/01-05.png" alt=""></p>
<p>2.对于每个个体检测是否拥有某个特定的基因，使用聚类算法来进行基因分类</p>
<p><img src="/imgs/machine-learning/01-06.png" alt=""></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="前言">前言</h1><p>最近开始学习C站上的NG的机器学习课程，会把视频中的内容写成笔记方便查阅，待学完后会将全部的笔记整理成PDF。</p>
<h1 id="监督学习（Supervised_Learning）">监督学习（Supervised Learnin]]>
    </summary>
    
      <category term="机器学习" scheme="http://codle.net/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习" scheme="http://codle.net/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hihoCoder编程练习赛：A 买零食]]></title>
    <link href="http://codle.net/2016/03/13/hiho-practice-match2-a/"/>
    <id>http://codle.net/2016/03/13/hiho-practice-match2-a/</id>
    <published>2016-03-13T10:41:44.000Z</published>
    <updated>2016-07-05T08:09:12.405Z</updated>
    <content type="html"><![CDATA[<h1 id="hihoCoder编程练习赛：A_买零食">hihoCoder编程练习赛：A 买零食</h1><p><img src="/imgs/hihocoder.png" alt=""></p>
<h2 id="描述">描述</h2><p>小Ho很喜欢在课间去小卖部买零食。然而不幸的是，这个学期他又有在一教的课，而一教的小卖部姐姐以冷若冰霜著称。第一次去一教小卖部买零食的时候，小Ho由于不懂事买了好一大堆东西，被小卖部姐姐给了一个“冷若冰霜”的眼神，食欲都下降了很多。</p>
<p>从那以后，小Ho就学乖了，去小卖部买东西只敢同时买3包以内的零食，并且价格加起来必须是5的整数倍，方便小卖部姐姐算价格。</p>
<p>但是小Ho不擅长计算，所以他把小卖部里所有零食的价格以及他对这个零食的渴望度都告诉了你，希望你能够帮他计算出在不惹恼小卖部姐姐的前提下，能够买到零食的渴望度之和最高是多少？</p>
<h2 id="输入">输入</h2><p>每个输入文件包含多组测试数据，在每个输入文件的第一行为一个整数Q，表示测试数据的组数。</p>
<p>每组测试数据的第一行为一个正整数N，表示小卖部中零食的数量。</p>
<p>接下来的N行，每行为一个正实数A和一个正整数B，表示这种零食的价格和小Ho对其的渴望度。</p>
<p>一种零食仅有一包。</p>
<p>对于100%的数据，满足1 &lt;= Q &lt;= 10，1&lt;=N&lt;=50，0&lt;A&lt;=10，1&lt;=B&lt;=100。</p>
<p>对于100%的数据，满足A的小数部分仅可能为0.5或0。</p>
<h2 id="输出">输出</h2><p>对于每组测试数据，输出一个整数Ans，表示小Ho可以获得最大的渴望度之和。</p>
<h3 id="样例输入">样例输入</h3><p>1<br>4<br>0.5 6<br>4.5 7<br>5.0 4<br>2.0 9</p>
<h3 id="样例输出">样例输出</h3><p>17</p>
<h2 id="解题思路">解题思路</h2><p>由于N最大只有50，也就是说最多计算量是$C_{50}^3$并不大，所以考虑直接暴力求解。由于看到有两个关联量，在自己做得时候直接就考虑了关联容器map，但是这两个量都是会出现重复的，不是唯一的，所以一直WA了很久才发现这问题，还是老老实实采取数组解决比较快。</p>
<h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFloat</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = (<span class="keyword">int</span>)d;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">fabs</span>(d - a) &lt; <span class="number">1e-8</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> Q;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; Q;</span><br><span class="line">	<span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">		<span class="keyword">int</span> N;</span><br><span class="line">		<span class="keyword">double</span> cost[<span class="number">100</span>];</span><br><span class="line">		<span class="keyword">int</span> val[<span class="number">100</span>];</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; N;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">			<span class="built_in">cin</span> &gt;&gt; cost[i] &gt;&gt; val[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">			<span class="keyword">double</span> c = cost[i];</span><br><span class="line">			<span class="keyword">if</span> (isFloat(c) &amp;&amp; (<span class="keyword">int</span>)c % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">				ans = max(ans, val[i]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">				<span class="keyword">double</span> c = cost[i] + cost[j];</span><br><span class="line">				<span class="keyword">if</span> (isFloat(c) &amp;&amp; (<span class="keyword">int</span>)c % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">					ans = max(ans, val[i] + val[j]);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">for</span> (<span class="keyword">int</span> k = j + <span class="number">1</span>; k &lt; N; k++) &#123;</span><br><span class="line">					<span class="keyword">double</span> c = cost[i] + cost[j] + cost[k];</span><br><span class="line">					<span class="keyword">if</span> (isFloat(c) &amp;&amp; (<span class="keyword">int</span>)c % <span class="number">5</span> == <span class="number">0</span>)</span><br><span class="line">						ans = max(ans, val[i] + val[j] + val[k]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="hihoCoder编程练习赛：A_买零食">hihoCoder编程练习赛：A 买零食</h1><p><img src="/imgs/hihocoder.png" alt=""></p>
<h2 id="描述">描述</h2><p>小Ho很喜欢在课间去小卖部买零食。]]>
    </summary>
    
      <category term="hiho" scheme="http://codle.net/tags/hiho/"/>
    
      <category term="算法" scheme="http://codle.net/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="习题集" scheme="http://codle.net/categories/%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hihoCoder第七十八周：Shortest Proper Prefix]]></title>
    <link href="http://codle.net/2015/12/28/hiho78/"/>
    <id>http://codle.net/2015/12/28/hiho78/</id>
    <published>2015-12-28T13:23:13.000Z</published>
    <updated>2016-07-05T08:53:50.135Z</updated>
    <content type="html"><![CDATA[<h1 id="hihoCoder第七十八周：Shortest_Proper_Prefix">hihoCoder第七十八周：Shortest Proper Prefix</h1><h2 id="题目">题目</h2><p>Query auto-completion(QAC) is widely used in many search applications. The basic idea is that when you type some string s in the search box several high-frequency queries which have s as a prefix are suggested. We say string s1 has string s2 as a prefix if and only if the first |s2| characters of s1 are the same as s2 where |s2| is the length of s2.</p>
<p><img src="http://media.hihocoder.com//problem_images/20150117/14214822852319.png" alt=""></p>
<p>These days Little Hi has been working on a way to improve the QAC performance. He collected N high-frequency queries. We say a string s is a proper prefix if there are no more than 5 collected queries have s as a prefix. A string s is a shortest proper prefix if s is a proper prefix and all the prefixes of s(except for s itself) are not proper prefixes. Little Hi wants to know the number of shortest proper prefixes given N collected queries.</p>
<p>Hint: the 4 shortest proper prefixes for Sample Input are “ab”, “bb”, “bc” and “be”. Empty string “” is not counted as a proper prefix even if N &lt;= 5.</p>
<p>输入<br>The first line contains N(N &lt;= 10000), the number of collected queries.<br>The following N lines each contain a query.<br>Each query contains only lowercase letters ‘a’-‘z’.<br>The total length of all queries are no more than 2000000.<br>Input may contain identical queries. Count them separately when you calculate the number of queries that have some string as a prefix.</p>
<p>输出<br>Output the number of shortest proper prefixes.</p>
<p>样例输入:<br>12<br>a<br>ab<br>abc<br>abcde<br>abcde<br>abcba<br>bcd<br>bcde<br>bcbbd<br>bcac<br>bee<br>bbb</p>
<p>样例输出:<br>4</p>
<h2 id="大意">大意</h2><p>给定N个单词，求满足下列条件的前缀集合S：</p>
<ul>
<li>集合中任意前缀对应的单词数量小于等于5</li>
<li>对于集合中任意前缀p，p的扩展前缀不属于该集合</li>
</ul>
<p>对于第二个条件，举个例子来说：</p>
<p>假设ab对应了5个单词，abc对应了3个单词，abd对应了2个单词。</p>
<p>因为ab对应的单词数量少于等于5，所以ab属于集合S。虽然abc和abd对应的单词数量均小于等于5，但由于其为ab的扩展，所以不属于S。</p>
<h2 id="解题思路">解题思路</h2><p>我们可以考虑构建Tire树来存储给出的字符串，Tire树如下图所示：</p>
<p><img src="http://media.hihocoder.com/contests/hiho78/hiho78.png" alt=""></p>
<p>这样我们只用对树进行深度优先搜索，找到结点的值小于五就返回，用一个全局变量储存返回的次数即所求的前缀个数。</p>
<h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> TireNode &#123;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">vector</span>&lt;TireNode*&gt; child;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span> str, TireNode* &amp;head)</span> </span>&#123;</span><br><span class="line">	TireNode* p = head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">char</span> ch : str) &#123;</span><br><span class="line">		<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">auto</span> it = p-&gt;child.begin();</span><br><span class="line">		<span class="keyword">for</span> (; it != p-&gt;child.end(); ++it) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((*it)-&gt;ch == ch) &#123;</span><br><span class="line">				(*it)-&gt;cnt++;</span><br><span class="line">				p = (*it);</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">			TireNode* tmp = <span class="keyword">new</span> TireNode;</span><br><span class="line">			tmp-&gt;ch = ch;</span><br><span class="line">			tmp-&gt;cnt++;</span><br><span class="line">			p-&gt;child.push_back(tmp);</span><br><span class="line">			p = tmp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TireNode* t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t-&gt;cnt &gt; <span class="number">5</span>) &#123;</span><br><span class="line">		<span class="keyword">auto</span> it = t-&gt;child.begin();</span><br><span class="line">		<span class="keyword">for</span> (; it != t-&gt;child.end(); ++it)</span><br><span class="line">			dfs(*it);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cnt++;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n;</span><br><span class="line">	<span class="built_in">string</span> tmp;</span><br><span class="line">	TireNode* t = <span class="keyword">new</span> TireNode;</span><br><span class="line">	t-&gt;cnt = <span class="number">6</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">	<span class="keyword">while</span> (n--) &#123;</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; tmp;</span><br><span class="line">		insert(tmp, t);</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(t);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="hihoCoder第七十八周：Shortest_Proper_Prefix">hihoCoder第七十八周：Shortest Proper Prefix</h1><h2 id="题目">题目</h2><p>Query auto-completion(QAC) is]]>
    </summary>
    
      <category term="hiho" scheme="http://codle.net/tags/hiho/"/>
    
      <category term="算法" scheme="http://codle.net/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="习题集" scheme="http://codle.net/categories/%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hihoCoder第七十二周：Disk Storage]]></title>
    <link href="http://codle.net/2015/11/16/hiho72/"/>
    <id>http://codle.net/2015/11/16/hiho72/</id>
    <published>2015-11-16T12:44:23.000Z</published>
    <updated>2016-07-05T08:53:43.515Z</updated>
    <content type="html"><![CDATA[<h1 id="hihoCoder第七十二周：Disk_Storage">hihoCoder第七十二周：Disk Storage</h1><h2 id="题目">题目</h2><p><img src="http://media.hihocoder.com//problem_images/20150103/14202824928356.png" alt=""></p>
<p>Little Hi and Little Ho have a disk storage. The storage’s shape is a truncated cone of height H. R+H is radius of top circle and R is radius of base circle.<br>Little Ho buys N disks today. Every disk is a cylinder of height 1. Little Ho wants to put these disk into the storage under below constraints:</p>
<ol>
<li>Every disk is placed horizontally. Its axis must coincide with the axis of storage.</li>
<li>Every disk is either place on the bottom surface or on another disk.</li>
<li>Between two neighboring disks in the storage, the upper one’s radius minus the lower one’s radius must be less than or equal to M.</li>
</ol>
<p>Little Ho wants to know how many disks he can put in the storage at most.</p>
<p>输入<br>Input contains only one testcase.<br>The first line contains 4 integers: N(1 &lt;= N &lt;= 100000), M, H, R(1 &lt;= M, R, H &lt;= 100000000).<br>The second line contains N integers, each number prepresenting the radius of a disk. Each radius is no more than 100000000.</p>
<p>输出<br>Output the maximum possible number of disks can be put into the storage.</p>
<p>样例输入<br>5 1 10 3<br>1 3 4 5 10<br>样例输出<br>4</p>
<h2 id="大意">大意</h2><p>在一个圆台中装圆形碟片，求问满足下面要求后最多能放几个圆碟：</p>
<ul>
<li>每个圆碟都放在中轴线上，每个圆碟都是挨着的</li>
<li>圆碟要么放在圆碟上要么放在水平面上</li>
<li>相邻两个圆碟，上面那个的半径减去下面那个的半径必须小于等于M</li>
</ul>
<h2 id="解题思路">解题思路</h2><p>上面那个减去下面那个半径小于等于M，并没有说是绝对值，因此从下到上假设摆成3-&gt;2-&gt;1这种也是满足要求的，因为都是负数小于M。因此解题思路就很明显了，先将圆碟按照半径排序，遍历直到有半径等于或者稍小于底面半径圆盘为止，显然之前已经被遍历的圆碟是一定能放的（只用按照从大到小的顺序摆在最上面即可），那么就从这个圆盘开始，依次查找满足M和R+H条件的圆盘即可。结果摆放如图所示：<br><img src="/imgs/hiho72.png" alt=""></p>
<h2 id="AC代码">AC代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m, h, r;</span><br><span class="line">	<span class="keyword">int</span> num1, num2;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; h &gt;&gt; r;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">100001</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	sort(a, a + n);</span><br><span class="line">	num1 = a[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">if</span> (a[<span class="number">0</span>] &gt; r) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	num2 = num1;</span><br><span class="line">	cnt++;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (a[i] &gt; r + cnt)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span> (a[i] - num1 &gt; m)</span><br><span class="line">			<span class="keyword">if</span> (a[i] &lt;= r) &#123;</span><br><span class="line">				num2 = a[i];</span><br><span class="line">				num1 = num2;</span><br><span class="line">				cnt = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			cnt++;</span><br><span class="line">			num1 = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; min(i, h) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="hihoCoder第七十二周：Disk_Storage">hihoCoder第七十二周：Disk Storage</h1><h2 id="题目">题目</h2><p><img src="http://media.hihocoder.com//problem_ima]]>
    </summary>
    
      <category term="hiho" scheme="http://codle.net/tags/hiho/"/>
    
      <category term="算法" scheme="http://codle.net/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="习题集" scheme="http://codle.net/categories/%E4%B9%A0%E9%A2%98%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法学习：动态规划]]></title>
    <link href="http://codle.net/2015/11/16/dp-pdf/"/>
    <id>http://codle.net/2015/11/16/dp-pdf/</id>
    <published>2015-11-16T07:10:32.000Z</published>
    <updated>2015-12-31T12:46:46.596Z</updated>
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文翻译自斯坦福大学的算法介绍课程PDF。英语水平不高，部分翻译可能比较生硬，还望见谅</p>
<h2 id="什么是动态规划">什么是动态规划</h2><blockquote>
<p>“通过将复杂问题分解为简单的子问题的方法” ————维基百科</p>
</blockquote>
<h2 id="动态规划的步骤">动态规划的步骤</h2><ol>
<li>定义子问题</li>
<li>找到子问题的递推关系</li>
<li>发现并解决每种基本情况</li>
</ol>
<h2 id="样例1:_区间型动态规划">样例1: 区间型动态规划</h2><h3 id="问题描述:">问题描述:</h3><p>给一个数n，求有多少种方案能通过1，3，4求和得到n？</p>
<h3 id="示例:">示例:</h3><p>对于一个数n = 5,答案是6<br>　５　＝　１　＋　１　＋　１　＋　１　＋　１<br>　　　＝　１　＋　１　＋　３<br>　　　＝　１　＋　３　＋　１<br>　　　＝　３　＋　１　＋　１<br>　　　＝　１　＋　４<br>　　　＝　４　＋　１</p>
<h3 id="定义子问题">定义子问题</h3><p>设$D_n$是用1,3,4求和得到n的方案总数</p>
<h3 id="找到子问题的递推关系">找到子问题的递推关系</h3><ul>
<li>思考一种可能的解决方案：n = $x_1 + x_2 + … + x_m$</li>
<li>如果$x_m$ = 1，那么剩下就需要求和至n-1</li>
<li>因此，以$x_m = 1$结尾的方案数量就等同于$D_{n-1}$ </li>
<li>对其他几种选择也使用上面的方法($x_m=3，x_m=4$)</li>
</ul>
<p>那么递推关系就出来:<br>$D_n = D_{n-1} + D_{n-3} + D_{n-4}$
　　</p>
<h3 id="解决基本情况">解决基本情况</h3><ul>
<li>$D_0 = 1$</li>
<li>$D_n = 0$ 用于初始化每个n的方案总数</li>
<li>当然，我们也可以设置：$D_0 = D_1 = D_2 = 1 且 D_3 = 2$</li>
</ul>
<h3 id="实现">实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D[<span class="number">0</span>] = D[<span class="number">1</span>] = D[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">D[<span class="number">3</span>] = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">4</span>; i &lt;= n; i++)</span><br><span class="line">    D[i] = D[i-<span class="number">1</span>] + D[i-<span class="number">3</span>] + D[i-<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<h2 id="例题:_POJ_2663:Tri_Tiling">例题: POJ 2663:Tri Tiling</h2><h3 id="问题描述:-1">问题描述:</h3><p>给一个数n，找出有多少种方案使用2 × 1的方块来填充3 × n的矩形</p>
<h3 id="示例：">示例：</h3><p>这里有一种填充n = 12的可行方案<br><img src="http://poj.org/images/2663_1.jpg" alt="&quot;n = 12&quot;"></p>
<h3 id="定义子问题-1">定义子问题</h3><p>设$D_n$是填充3 × n矩形的总方案数</p>
<h3 id="找出递推关系">找出递推关系</h3><p>很明显可以分析得出n为奇数时无法拼出矩形，那么下面都针对偶数的情况进行分析。<br>在n-2是拼好的情况下，要拼出n层的矩形有如下三种拼接方式。<br><img src="/imgs/dp001.png" alt=""></p>
<p>此时可以得出 $D_n = 3 × D_{n-2}$</p>
<p>但这只是解决了当第n-2是矩形的情况下的子问题。</p>
<p>那么当n-2不是矩形时能否让n层拼出矩形呢？<br>有如下两种方案可以实现：<br><img src="/imgs/dp002.png" alt=""></p>
<p>此时$D_n = ?$<br>$D_n = 3 × D_{n-2} + 2^{(n-2)/2}$?</p>
<p>这里显然不能把每个关节点想成是独立的问题来求幂运算，因为一旦一个关节开始按照方案来摆放，后面的摆放就已经是固定的了！不然无法完整的拼出一整个矩形。如下图：<br><img src="/imgs/dp003.png" alt=""><br>一旦按照黄色部分拼接，那么后面到n-2的地方都必须按照蓝色的方式进行拼接。<br>所以，正确的递推关系应该是:<br>$D_n = 3 × D_{n-2} + 2 × D_{n-4} + 2 × D_{n-6} + … + 2 × D_{0}$<br>我们对上式化简，左右同时减去$D_{n-2} = 3 × D_{n-4} + 2 × D_{n-6} + … + 2 × D_{0}$<br>得到：<br>$D_n - D_{n-2} = 3 × D_{n-2} - D_{n-4}$<br>$D_n = 4 × D_{n-2} - D_{n-4}$</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="前言">前言</h2><p>本文翻译自斯坦福大学的算法介绍课程PDF。英语水平不高，部分翻译可能比较生硬，还望见谅</p>
<h2 id="什么是动态规划">什么是动态规划</h2><blockquote>
<p>“通过将复杂问题分解为简单的子问题的方法” ———]]>
    </summary>
    
      <category term="算法" scheme="http://codle.net/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习" scheme="http://codle.net/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[算法学习：回文串]]></title>
    <link href="http://codle.net/2015/11/03/ispalindrome/"/>
    <id>http://codle.net/2015/11/03/ispalindrome/</id>
    <published>2015-11-03T09:57:40.000Z</published>
    <updated>2016-07-05T08:55:32.651Z</updated>
    <content type="html"><![CDATA[<h1 id="算法学习：回文串">算法学习：回文串</h1><h2 id="前言">前言</h2><p>所谓回文串，就是从开头顺序读或者从结尾向前面读都一样的字符串（或链表），如abcdcba，madam。回文串能够轻易考验对字符串的应用，因此关于回文串的题目也是非常的广泛。</p>
<h2 id="判断回文">判断回文</h2><h3 id="题目描述">题目描述</h3><p>给定一个字符串，如何判断这个字符串是否是回文串。<br><img src="/imgs/algorithm.jpg" alt=""><br><a id="more"></a></p>
<h3 id="分析与解法：">分析与解法：</h3><h4 id="解法一：两头向中间扫">解法一：两头向中间扫</h4><p>找到这个字符串的开头和结尾，然后从两端开始向中间扫描，扫描过程中，如果对应的字符都相同，那么说明这个字符串回文。当前端超过或者等于后端时候结束扫描。<br>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!s.size())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> back = s.size() - <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> front = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (front &lt; back) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[front]!=s[back])</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		front++;</span><br><span class="line">		back--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间复杂度O(n),空间复杂度O(1)。</p>
<h4 id="解法二：中间向两头扫">解法二：中间向两头扫</h4><p>找到中间元素，然后向两端以此扫描查看是否相同，难点在于找到中点后的起点位置，字符串长度是奇数或者偶数是不同的。<br>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!s.size())</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">int</span> n = s.size();</span><br><span class="line">	<span class="keyword">int</span> front, back;</span><br><span class="line">	<span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">		front = n / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">		back = n / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		front = back = n / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">for</span> (; front &gt;= <span class="number">0</span>; front--, back++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (s[front] != s[back])</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>时间空间复杂度和解法一相同，分别是O(n)和O(1)。</p>
<h2 id="链表判断回文">链表判断回文</h2><h3 id="题目描述-1">题目描述</h3><p>判断一条单向链表是不是回文</p>
<h3 id="分析与算法">分析与算法</h3><p>由于是单链表，单向传递无法使用两个指针来扫描。可以扫描一次找到中点，然后再来进行一次扫描，从开头和中点来开始扫描进行比较，但是这样扫描了两次会增加时间复杂度。我们这里考虑使用快慢指针的方法，用两个指针来开始扫描，一个指针每次递增一步，一个每次递增两步。当快的指针到达链表尾部是，慢的指针就到达了链表的中点。然后我们倒置后半段链表与开头进行比较判断是否是回文串。<br>参考代码如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(Node* t)</span> </span>&#123;</span><br><span class="line">	Node* slow = t;</span><br><span class="line">	Node* flast = t;</span><br><span class="line">	Node* l = <span class="keyword">new</span> Node;</span><br><span class="line">	Node* p;</span><br><span class="line">	Node* tl;</span><br><span class="line">	<span class="keyword">while</span> (flast-&gt;next) &#123;</span><br><span class="line">		slow = slow-&gt;next;</span><br><span class="line">		flast = flast-&gt;next;</span><br><span class="line">		<span class="keyword">if</span> (flast-&gt;next)</span><br><span class="line">			flast = flast-&gt;next;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	p = slow;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">		Node* temp = <span class="keyword">new</span> Node(p-&gt;next-&gt;val);</span><br><span class="line">		temp-&gt;next = l-&gt;next;</span><br><span class="line">		l-&gt;next = temp;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (p = t-&gt;next, tl = l-&gt;next; tl != <span class="literal">NULL</span>; p = p-&gt;next, tl = tl-&gt;next) &#123;</span><br><span class="line">		<span class="keyword">if</span> (p-&gt;val != tl-&gt;val)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="算法学习：回文串">算法学习：回文串</h1><h2 id="前言">前言</h2><p>所谓回文串，就是从开头顺序读或者从结尾向前面读都一样的字符串（或链表），如abcdcba，madam。回文串能够轻易考验对字符串的应用，因此关于回文串的题目也是非常的广泛。</p>
<h2 id="判断回文">判断回文</h2><h3 id="题目描述">题目描述</h3><p>给定一个字符串，如何判断这个字符串是否是回文串。<br><img src="/imgs/algorithm.jpg" alt=""><br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://codle.net/tags/C/"/>
    
      <category term="算法" scheme="http://codle.net/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法学习" scheme="http://codle.net/categories/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[数据结构：二叉树（C++版）]]></title>
    <link href="http://codle.net/2015/10/29/binary-tree/"/>
    <id>http://codle.net/2015/10/29/binary-tree/</id>
    <published>2015-10-29T12:48:30.000Z</published>
    <updated>2016-07-05T09:00:18.735Z</updated>
    <content type="html"><![CDATA[<h1 id="数据结构：二叉树（C++版）">数据结构：二叉树（C++版）</h1><h2 id="二叉树的定义">二叉树的定义</h2><p>二叉树是每个节点最多有两个子树的树形结构，二叉树的子树有左右之分，其次序不能颠倒。<br>其中：</p>
<ul>
<li>二叉树第i层至多有$2^{i-1}$个节点（节点最多，则说明前面层都是满的，则每层都是上一层的两倍，第一层有$2^0$=1个节点）；</li>
<li>深度为k的二叉树至多有$2^{k-1}$个节点（即是说k-1层全满的情况，那么每层分别有$2^0$,$2^1$,$2^2$…$2^{k-1}$个节点，等比数列求和可得$2^k-1$）；</li>
</ul>
<p>一棵深度为k，且有$2^{k-1}$个节点称之为满二叉树；深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树。</p>
<p><img src="/imgs/useful.png" alt=""><br><a id="more"></a></p>
<h2 id="二叉树的储存">二叉树的储存</h2><h3 id="链式存储">链式存储</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">Node</span><span class="identifier"> </span><span class="title">&#123;  </span><br><span class="line">	ElemType</span> val;	//本结点储存值  </span><br><span class="line">	<span class="keyword">Node</span><span class="identifier"></span><span class="title">* left</span>;     //结点指针用于储存左子树  </span><br><span class="line">	<span class="keyword">Node</span><span class="identifier"></span><span class="title">* right</span>;	//结点指针用于储存右子树  </span><br><span class="line">        //构造函数，方便调用关键字new来构造节点  </span><br><span class="line">	<span class="keyword">Node</span><span class="identifier"></span><span class="title">(ElemType</span> v=<span class="number">0</span>) &#123;  </span><br><span class="line">		val = v;  </span><br><span class="line">		left = right = NULL;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>链式存储也是最常见的二叉树存储方式</p>
<h3 id="数组存储">数组存储</h3><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElemType <span class="keyword">val</span>[T];    <span class="comment">//T=2^k-1 k为二叉树深度</span></span><br></pre></td></tr></table></figure>
<p>数组的长度就是把当前二叉树当成满二叉树的情况下的结点数。假设一个父节点的下标序号是i，那么：</p>
<ul>
<li>左孩子的结点下标为i*2;</li>
<li>右孩子的结点下标为i*2+1;</li>
</ul>
<h2 id="二叉树的一些操作">二叉树的一些操作</h2><h3 id="二叉树的遍历">二叉树的遍历</h3><p>对于一个二叉树，遍历是最基本的操作，遍历二叉树即是说按照一定规则走完整个二叉树，使得每个结点被访问一次且只被访问一次。二叉树的遍历操作有：前序，中序，后序以及层序遍历。</p>
<h4 id="先序遍历">先序遍历</h4><p>先序遍历的遍历顺序是先访问根节点，然后访问左节点，最后访问右节点，算法实现如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> preOrderView(Node* T) &#123;		<span class="comment">//一个递归函数</span></span><br><span class="line">	<span class="comment">//当前判断当前结点是否为空，为空就回溯</span></span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		cout &lt;&lt; T<span class="subst">-&gt;</span>val &lt;&lt; <span class="string">" "</span>;	<span class="comment">//打印当前结点的值，即是访问根节点</span></span><br><span class="line">		preOrderView(T<span class="subst">-&gt;</span>left);	<span class="comment">//访问当前节点的左节点</span></span><br><span class="line">		preOrderView(T<span class="subst">-&gt;</span>right);	<span class="comment">//访问当前节点的右节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="中序遍历">中序遍历</h4><p>中序遍历的遍历顺序是左–&gt;根–&gt;右，算法与先序遍历基本一致:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> inOrdereView(Node* T) &#123;		<span class="comment">//一个递归函数</span></span><br><span class="line">	<span class="comment">//当前判断当前结点是否为空，为空就回溯</span></span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		inOrdereView(T<span class="subst">-&gt;</span>left);	<span class="comment">//访问当前节点的左节点</span></span><br><span class="line">		cout &lt;&lt; T<span class="subst">-&gt;</span>val &lt;&lt; <span class="string">" "</span>;	<span class="comment">//打印当前结点的值，即是访问根节点</span></span><br><span class="line">		inOrdereView(T<span class="subst">-&gt;</span>right);	<span class="comment">//访问当前节点的右节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="后序遍历">后序遍历</h4><p>后序遍历的遍历顺序是左–&gt;右–&gt;根，算法与上述两个基本相同:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> postOrdereView(Node* T) &#123;			<span class="comment">//一个递归函数</span></span><br><span class="line">	<span class="comment">//当前判断当前结点是否为空，为空就回溯</span></span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		postOrdereView(T<span class="subst">-&gt;</span>left);	<span class="comment">//访问当前节点的左节点</span></span><br><span class="line">		postOrdereView(T<span class="subst">-&gt;</span>right);	<span class="comment">//访问当前节点的右节点</span></span><br><span class="line">		cout &lt;&lt; T<span class="subst">-&gt;</span>val &lt;&lt; <span class="string">" "</span>;		<span class="comment">//打印当前结点的值，即是访问根节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="层序遍历">层序遍历</h4><p>不同于上述三种遍历，层序遍历即是一层一层的访问二叉树的节点，使用的算法思想是广度优先搜索，使用辅助队列来存储每一层的节点。算法实现如下:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> levelOrderView(Node* T) &#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;Node*&gt; q;				<span class="comment">//声明一个队列，这里使用了STL,也可以自己写</span></span><br><span class="line">	Node* t;				<span class="comment">//存取队列元素</span></span><br><span class="line">	q<span class="built_in">.</span>push(T);				<span class="comment">//把根节点放入队列</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="subst">!</span>q<span class="built_in">.</span>empty()) &#123;			<span class="comment">//当队列不为空的时候执行循环</span></span><br><span class="line">		t = q<span class="built_in">.</span>front();			<span class="comment">//t取队头元素</span></span><br><span class="line">		<span class="keyword">if</span> (t<span class="subst">-&gt;</span>left)			<span class="comment">//如果t的左孩子不为空，那么放入队列中</span></span><br><span class="line">			q<span class="built_in">.</span>push(t<span class="subst">-&gt;</span>left);</span><br><span class="line">		<span class="keyword">if</span> (t<span class="subst">-&gt;</span>right)			<span class="comment">//同上</span></span><br><span class="line">			q<span class="built_in">.</span>push(t<span class="subst">-&gt;</span>right);</span><br><span class="line">		q<span class="built_in">.</span>pop();			<span class="comment">//抛出队头元素</span></span><br><span class="line">		cout &lt;&lt; t<span class="subst">-&gt;</span>val &lt;&lt; <span class="string">" "</span>;		<span class="comment">//打印队头元素的值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="通过遍历结果建树">通过遍历结果建树</h3><p>前面我们讲述了三种基本的遍历二叉树方法（前序，中序，后序遍历），那么下面我们将讲述如何通过前序和中序序列或者后序和中序序列来构建这颗二叉树。</p>
<h4 id="前序和中序序列建树">前序和中序序列建树</h4><p>在前序遍历中，遍历二叉树的顺序是根–&gt;左–&gt;右的顺序，而在中序遍历中，遍历顺序是左–&gt;根–&gt;右的顺序。在两者生成的遍历序列中，我们可以很快发现，前序遍历的第一个元素就是该二叉树的根节点，然后再去中序遍历中找到这个元素，因为中序是左–&gt;根–&gt;右的遍历顺序，那么在根节点左侧的字符串就是该根节点的左子树，右侧的字符串就是该节点的右子树。那么对子树，我们有可以从前序遍历中找到相应根节点然后重复做上述步骤，这样就完成了一棵二叉树的建立。由于步骤是一个重复的过程，我们可以使用递归的方式来进行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="built_in">string</span> inOrder, <span class="built_in">string</span> preOrder, Node* &amp;t)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> inL, inR, preL, preR;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;                      <span class="comment">//标志变量用于判断是否找到根节点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inOrder.size(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inOrder[i] == preOrder[<span class="number">0</span>]) &#123;    <span class="comment">//查找根节点</span></span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;              	<span class="comment">//在没找到根节点时，把遍历的字符串放入左子树串</span></span><br><span class="line">			inL.push_back(inOrder[i]);</span><br><span class="line">			preL.push_back(preOrder[i + <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;                              	<span class="comment">//找到了后就放入右子树串</span></span><br><span class="line">			inR.push_back(inOrder[i]);</span><br><span class="line">			preR.push_back(preOrder[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;val = preOrder[<span class="number">0</span>];                   <span class="comment">//把当前根值赋给根节点</span></span><br><span class="line">	<span class="keyword">if</span> (inL.size()) &#123;                       <span class="comment">//如果左子树串不为空，那么递归调用，对左子树进行构树</span></span><br><span class="line">		t-&gt;left = <span class="keyword">new</span> Node;</span><br><span class="line">		buildTree(inL, preL, t-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (inR.size()) &#123;                       <span class="comment">//如果右子树串不空，就对右子树构树。</span></span><br><span class="line">		t-&gt;right = <span class="keyword">new</span> Node;</span><br><span class="line">		buildTree(inR, preR, t-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="后序和中序序列建树">后序和中序序列建树</h4><p>后序和中序序列建树的方法大致思路相同，只是在寻找根节点的方法不同，因为后序遍历的顺序是左–&gt;右–&gt;根，所以后序遍历的最后一个元素是根节点，和前序遍历的首元素不同。其他思路可以参考上文，下面是代码的实现:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree2</span><span class="params">(<span class="built_in">string</span> inOrder, <span class="built_in">string</span> postOrder, Node* &amp;t)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> inL, inR, postL, postR;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inOrder.size(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inOrder[i] == postOrder[postOrder.size() - <span class="number">1</span>]) &#123;</span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">			inL.push_back(inOrder[i]);</span><br><span class="line">			postL.push_back(postOrder[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			inR.push_back(inOrder[i]);</span><br><span class="line">			postR.push_back(postOrder[i - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;val = postOrder[postOrder.size() - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (inL.size()) &#123;</span><br><span class="line">		t-&gt;left = <span class="keyword">new</span> Node;</span><br><span class="line">		buildTree2(inL, postL, t-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (inR.size()) &#123;</span><br><span class="line">		t-&gt;right = <span class="keyword">new</span> Node;</span><br><span class="line">		buildTree2(inR, postR, t-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="数据结构：二叉树（C++版）">数据结构：二叉树（C++版）</h1><h2 id="二叉树的定义">二叉树的定义</h2><p>二叉树是每个节点最多有两个子树的树形结构，二叉树的子树有左右之分，其次序不能颠倒。<br>其中：</p>
<ul>
<li>二叉树第i层至多有$2^{i-1}$个节点（节点最多，则说明前面层都是满的，则每层都是上一层的两倍，第一层有$2^0$=1个节点）；</li>
<li>深度为k的二叉树至多有$2^{k-1}$个节点（即是说k-1层全满的情况，那么每层分别有$2^0$,$2^1$,$2^2$…$2^{k-1}$个节点，等比数列求和可得$2^k-1$）；</li>
</ul>
<p>一棵深度为k，且有$2^{k-1}$个节点称之为满二叉树；深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树。</p>
<p><img src="/imgs/useful.png" alt=""><br>]]>
    
    </summary>
    
      <category term="C++" scheme="http://codle.net/tags/C/"/>
    
      <category term="数据结构" scheme="http://codle.net/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构" scheme="http://codle.net/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用hexo搭建个人博客]]></title>
    <link href="http://codle.net/2015/10/29/how-to-build-hexo/"/>
    <id>http://codle.net/2015/10/29/how-to-build-hexo/</id>
    <published>2015-10-29T07:08:54.000Z</published>
    <updated>2016-07-05T08:56:14.589Z</updated>
    <content type="html"><![CDATA[<h1 id="使用hexo搭建个人博客">使用hexo搭建个人博客</h1><h2 id="前言">前言</h2><p>折腾了两天终于做好了这个博客站，相比于wordpress+虚拟空间的组合，使用Github Page+hexo无疑显得要更加轻便与稳定。<br>下面就来谈一谈是如何在Github上搭建一个hexo博客的。</p>
<p><img src="/imgs/post1.jpg" alt="&quot;Hexo&quot;"></p>
<a id="more"></a>
<h2 id="搭建环境">搭建环境</h2><p>hexo是一个基于node.js的静态博客框架，因此电脑需要安装node.js环境，同时也需要Git软件用于上传博客文件</p>
<ul>
<li><a href="http://nodejs.org" target="_blank" rel="external">Node.js</a></li>
<li><a href="http://git-scm.com/" target="_blank" rel="external">Git</a></li>
</ul>
<h2 id="注册GitHub">注册GitHub</h2><p>访问<a href="http://www.github.com/" target="_blank" rel="external">GitHub</a>官网注册一个账号。</p>
<p>邮箱请确保能收到消息，GitHub上的消息都是通过邮件通知的。</p>
<h2 id="配置和使用GitHub">配置和使用GitHub</h2><p>在注册完GitHub后，进行一些必要的SSH配置，以确保本地Git项目能与远程的Github联系。</p>
<h3 id="检查SSH_Keys">检查SSH Keys</h3><p>首先检查电脑上现有的SSH Keys，打开之前安装的Git Bash，输入：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh &#26816;&#26597;&#26412;&#26426;ssh&#23494;&#38053;</span><br></pre></td></tr></table></figure></p>
<p>如果提示: No such file or directory 说明是第一次使用git。</p>
<h3 id="生成新的SSH_Key：">生成新的SSH Key：</h3><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"邮件地址@youremail.com"</span></span><br><span class="line">Generating <span class="keyword">public</span>/<span class="keyword">private</span> rsa <span class="keyword">key</span> pair.</span><br><span class="line">Enter file <span class="keyword">in</span> which <span class="keyword">to</span> save the <span class="keyword">key</span> (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>邮件地址填入你自己的邮箱地址</li>
<li>-C是大写的C，且每个-前面都是有一个空格的</li>
</ul>
<p>然后系统会要求你创建密码：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):<span class="variable">&lt;输入加密串&gt;</span></span><br><span class="line">Enter same passphrase again:<span class="variable">&lt;再次输入加密串&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这个密码在你之后提交项目时使用，如果为空的话在提交项目时可以不输入。这是为了防止别人在你的项目里面提交文件。</p>
<p>注意：输入密码时候不会显示字符或者*，直接输完回车即可。</p>
<p>看到显示一个方框图形就表示成功设置SSH Key了。</p>
<h3 id="添加SSH_Key到GitHub">添加SSH Key到GitHub</h3><p>本机设置SSH Key后，需要添加到GitHub上，已完成SSH链接的设置。</p>
<ol>
<li>用记事本打开本地C:\Users\用户名.ssh\id_rsa.pub文件。这个文件里面内容是刚刚生成的密钥。如果看不到文件，你需要设置显示隐藏文件。ctrl+a复制全部文本。</li>
<li>登陆github。点击右上角头像Settings-&gt;SSH Keys-&gt;Add SSH Key。title可以随便取名，把刚才复制的内容粘贴进Key里面去。</li>
<li>点击Add Key完成设置。</li>
</ol>
<h3 id="测试SSH_Key">测试SSH Key</h3><p>输入下面的命令，看看设置是否成功，请勿改动命令内容:<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh -<span class="constant">T</span> git<span class="variable">@github</span>.com</span><br></pre></td></tr></table></figure></p>
<p>会出现如下内容:<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity <span class="keyword">of</span> host <span class="comment">'github.com (207.97.227.239)' can't be established.</span></span><br><span class="line">RSA <span class="keyword">key</span> fingerprint <span class="keyword">is</span> <span class="number">16</span>:<span class="number">27</span>:ac:a5:<span class="number">76</span>:<span class="number">28</span>:<span class="number">2</span>d:<span class="number">36</span>:<span class="number">63</span>:<span class="number">1</span>b:<span class="number">56</span>:<span class="number">4</span>d:eb:df:a6:<span class="number">48.</span></span><br><span class="line">Are you sure you want <span class="keyword">to</span> <span class="keyword">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure></p>
<p>输入yes即可，如果之前设置了SSH Key密码，那么还会要求输入之前的密码<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi user! You've successfully authenticated, <span class="keyword">but</span> GitHub <span class="keyword">does</span> <span class="keyword">not</span> provide shell access.</span><br></pre></td></tr></table></figure></p>
<h3 id="设置用户信息">设置用户信息</h3><p>Git通过用户的名字和邮箱来上传文件，输入下面的代码进行个人信息的设置。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user<span class="class">.name</span> <span class="string">"user"</span><span class="comment">//用户名</span></span><br><span class="line">$ git config --global user<span class="class">.email</span>  <span class="string">"user@gmail.com"</span><span class="comment">//填写自己的邮箱</span></span><br></pre></td></tr></table></figure></p>
<h3 id="SSH_Key配置成功">SSH Key配置成功</h3><p>如果中途出现问题，请按照步骤从头再来一次。</p>
<h2 id="使用GitHub_Page建立博客">使用GitHub Page建立博客</h2><p>GitHub Page是GitHub提供给每个用户的一个功能。可以通过username.github.io的方式进行访问，每个用户名下只能创建一个。</p>
<h3 id="建立仓库">建立仓库</h3><p>登陆GitHub，点击 New Repository 填写项目信息。</p>
<ul>
<li>project name ：username.github.io</li>
<li>description :填写项目描述，可以不写</li>
</ul>
<p>注意：username一定是你的Github名字。</p>
<h2 id="使用hexo">使用hexo</h2><h3 id="安装">安装</h3><p>打开Git Bash，运行下面的命令：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> hexo</span></span><br></pre></td></tr></table></figure></p>
<p>自己在磁盘中建一个名为hexo的文件夹，在Git Bash中使用cd命令进入hexo文件夹下，运行下面的命令:<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo init</span><br></pre></td></tr></table></figure></p>
<p>就完成了hexo的本地博客安装。</p>
<h3 id="本地浏览">本地浏览</h3><p>我们可以通过下面的命令在本地查看博客：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo s</span><br></pre></td></tr></table></figure></p>
<p>在浏览器输入 localhost:4000 查看。</p>
<h3 id="_config-yml文件">_config.yml文件</h3><p>hexo文件根目录下的_config.yml存储了一些关于博客的基础设置，可以自己查看酌情修改。而theme里面的主题文件对应的_config.yml则是修改主题设置的。</p>
<h3 id="上载自己的博客程序">上载自己的博客程序</h3><p>部署到GitHub前需要配置根目录下的_config.yml文件。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">    <span class="attribute">type</span>: github</span><br><span class="line">    <span class="attribute">repository</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:username/username.github.com.git</span><br><span class="line">    <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></p>
<p>之后执行下列指令即可完成部署:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="keyword">g</span></span><br><span class="line">hexo <span class="literal">d</span></span><br></pre></td></tr></table></figure></p>
<p>也可以直接输入：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="keyword">d</span> -<span class="keyword">g</span></span><br></pre></td></tr></table></figure></p>
<p>即完成了博客的上传。上传完成后就可以通过username.github.io访问你的博客了。</p>
<h2 id="DNS解析">DNS解析</h2><p>如何将博客解析到自己的域名上？可以通过如下设置完成：<br>添加两条A记录:</p>
<ul>
<li>192.30.252.153</li>
<li>192.30.252.154</li>
</ul>
<p>在hexo\sourcex下新建记事本，写上自己的域名，然后改名为CNAME(注意没有后缀名)，然后上载博客。<br>在域名管理中添加CNAME解析，主机记录添加wwww,记录值改为 username.github.io 。</p>
<h2 id="后记">后记</h2><p>感谢各位大大提供的教程:</p>
<ul>
<li><a href="http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></li>
<li><a href="http://yangjian.me/workspace/building-blog-with-hexo/" target="_blank" rel="external">使用hexo搭建博客</a></li>
</ul>
<p>附上需要的链接：</p>
<ul>
<li><a href="https://hexo.io/" target="_blank" rel="external">Hexo官网（是台湾前辈开发的，因此很多文档都带有繁中）</a></li>
<li><a href="https://hexo.io/" target="_blank" rel="external">GitHub Page（如果Ip无法解析了，请及时来看）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="使用hexo搭建个人博客">使用hexo搭建个人博客</h1><h2 id="前言">前言</h2><p>折腾了两天终于做好了这个博客站，相比于wordpress+虚拟空间的组合，使用Github Page+hexo无疑显得要更加轻便与稳定。<br>下面就来谈一谈是如何在Github上搭建一个hexo博客的。</p>
<p><img src="/imgs/post1.jpg" alt="&quot;Hexo&quot;"></p>]]>
    
    </summary>
    
      <category term="blog" scheme="http://codle.net/tags/blog/"/>
    
      <category term="hexo" scheme="http://codle.net/tags/hexo/"/>
    
      <category term="博客相关" scheme="http://codle.net/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
</feed>
