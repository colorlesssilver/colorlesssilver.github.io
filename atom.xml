<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Silver's Codle]]></title>
  <subtitle><![CDATA[无比芜杂的心绪]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://codle.net/"/>
  <updated>2015-11-03T07:47:01.439Z</updated>
  <id>http://codle.net/</id>
  
  <author>
    <name><![CDATA[Silver]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[数据结构：二叉树（C++版）]]></title>
    <link href="http://codle.net/2015/10/29/binary-tree/"/>
    <id>http://codle.net/2015/10/29/binary-tree/</id>
    <published>2015-10-29T12:48:30.000Z</published>
    <updated>2015-11-03T07:47:01.439Z</updated>
    <content type="html"><![CDATA[<h1 id="数据结构：二叉树（C++版）">数据结构：二叉树（C++版）</h1><h2 id="二叉树的定义">二叉树的定义</h2><p>二叉树是每个节点最多有两个子树的树形结构，二叉树的子树有左右之分，其次序不能颠倒。<br>其中：</p>
<ul>
<li>二叉树第i层至多有2^(i-1)个节点（节点最多，则说明前面层都是满的，则每层都是上一层的两倍，第一层有2^0=1个节点）；</li>
<li>深度为k的二叉树至多有2^k-1个节点（即是说1-k层全满的情况，那么每层分别有2^0,2^1,2^2…2^(k-1)个节点，等比数列求和可得2^k-1）；</li>
</ul>
<p>一棵深度为k，且有2^k-1个节点称之为满二叉树；深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中，序号为1至n的节点对应时，称之为完全二叉树。</p>
<h2 id="二叉树的储存">二叉树的储存</h2><h3 id="链式存储">链式存储</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct <span class="keyword">Node</span><span class="identifier"> </span><span class="title">&#123;  </span><br><span class="line">	ElemType</span> val;	//本结点储存值  </span><br><span class="line">	<span class="keyword">Node</span><span class="identifier"></span><span class="title">* left</span>;     //结点指针用于储存左子树  </span><br><span class="line">	<span class="keyword">Node</span><span class="identifier"></span><span class="title">* right</span>;	//结点指针用于储存右子树  </span><br><span class="line">        //构造函数，方便调用关键字new来构造节点  </span><br><span class="line">	<span class="keyword">Node</span><span class="identifier"></span><span class="title">(ElemType</span> v=<span class="number">0</span>) &#123;  </span><br><span class="line">		val = v;  </span><br><span class="line">		left = right = NULL;  </span><br><span class="line">        &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>链式存储也是最常见的二叉树存储方式</p>
<h3 id="数组存储">数组存储</h3><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ElemType <span class="keyword">val</span>[T];    <span class="comment">//T=2^k-1 k为二叉树深度</span></span><br></pre></td></tr></table></figure>
<p>数组的长度就是把当前二叉树当成满二叉树的情况下的结点数。假设一个父节点的下标序号是i，那么：</p>
<ul>
<li>左孩子的结点下标为i*2;</li>
<li>右孩子的结点下标为i*2+1;</li>
</ul>
<h2 id="二叉树的一些操作">二叉树的一些操作</h2><h3 id="二叉树的遍历">二叉树的遍历</h3><p>对于一个二叉树，遍历是最基本的操作，遍历二叉树即是说按照一定规则走完整个二叉树，使得每个结点被访问一次且只被访问一次。二叉树的遍历操作有：前序，中序，后序以及层序遍历。</p>
<h4 id="先序遍历">先序遍历</h4><p>先序遍历的遍历顺序是先访问根节点，然后访问左节点，最后访问右节点，算法实现如下：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> preOrderView(Node* T) &#123;		<span class="comment">//一个递归函数</span></span><br><span class="line">	<span class="comment">//当前判断当前结点是否为空，为空就回溯</span></span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		cout &lt;&lt; T<span class="subst">-&gt;</span>val &lt;&lt; <span class="string">" "</span>;	<span class="comment">//打印当前结点的值，即是访问根节点</span></span><br><span class="line">		preOrderView(T<span class="subst">-&gt;</span>left);	<span class="comment">//访问当前节点的左节点</span></span><br><span class="line">		preOrderView(T<span class="subst">-&gt;</span>right);	<span class="comment">//访问当前节点的右节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="中序遍历">中序遍历</h4><p>中序遍历的遍历顺序是左–&gt;根–&gt;右，算法与先序遍历基本一致:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> inOrdereView(Node* T) &#123;		<span class="comment">//一个递归函数</span></span><br><span class="line">	<span class="comment">//当前判断当前结点是否为空，为空就回溯</span></span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		inOrdereView(T<span class="subst">-&gt;</span>left);	<span class="comment">//访问当前节点的左节点</span></span><br><span class="line">		cout &lt;&lt; T<span class="subst">-&gt;</span>val &lt;&lt; <span class="string">" "</span>;	<span class="comment">//打印当前结点的值，即是访问根节点</span></span><br><span class="line">		inOrdereView(T<span class="subst">-&gt;</span>right);	<span class="comment">//访问当前节点的右节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="后序遍历">后序遍历</h4><p>后序遍历的遍历顺序是左–&gt;右–&gt;根，算法与上述两个基本相同:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> postOrdereView(Node* T) &#123;			<span class="comment">//一个递归函数</span></span><br><span class="line">	<span class="comment">//当前判断当前结点是否为空，为空就回溯</span></span><br><span class="line">	<span class="keyword">if</span> (T) &#123;</span><br><span class="line">		postOrdereView(T<span class="subst">-&gt;</span>left);	<span class="comment">//访问当前节点的左节点</span></span><br><span class="line">		postOrdereView(T<span class="subst">-&gt;</span>right);	<span class="comment">//访问当前节点的右节点</span></span><br><span class="line">		cout &lt;&lt; T<span class="subst">-&gt;</span>val &lt;&lt; <span class="string">" "</span>;		<span class="comment">//打印当前结点的值，即是访问根节点</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="层序遍历">层序遍历</h4><p>不同于上述三种遍历，层序遍历即是一层一层的访问二叉树的节点，使用的算法思想是广度优先搜索，使用辅助队列来存储每一层的节点。算法实现如下:<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> levelOrderView(Node* T) &#123;</span><br><span class="line">	<span class="built_in">queue</span>&lt;Node*&gt; q;				<span class="comment">//声明一个队列，这里使用了STL,也可以自己写</span></span><br><span class="line">	Node* t;				<span class="comment">//存取队列元素</span></span><br><span class="line">	q<span class="built_in">.</span>push(T);				<span class="comment">//把根节点放入队列</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="subst">!</span>q<span class="built_in">.</span>empty()) &#123;			<span class="comment">//当队列不为空的时候执行循环</span></span><br><span class="line">		t = q<span class="built_in">.</span>front();			<span class="comment">//t取队头元素</span></span><br><span class="line">		<span class="keyword">if</span> (t<span class="subst">-&gt;</span>left)			<span class="comment">//如果t的左孩子不为空，那么放入队列中</span></span><br><span class="line">			q<span class="built_in">.</span>push(t<span class="subst">-&gt;</span>left);</span><br><span class="line">		<span class="keyword">if</span> (t<span class="subst">-&gt;</span>right)			<span class="comment">//同上</span></span><br><span class="line">			q<span class="built_in">.</span>push(t<span class="subst">-&gt;</span>right);</span><br><span class="line">		q<span class="built_in">.</span>pop();			<span class="comment">//抛出队头元素</span></span><br><span class="line">		cout &lt;&lt; t<span class="subst">-&gt;</span>val &lt;&lt; <span class="string">" "</span>;		<span class="comment">//打印队头元素的值</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="通过遍历结果建树">通过遍历结果建树</h3><p>前面我们讲述了三种基本的遍历二叉树方法（前序，中序，后序遍历），那么下面我们将讲述如何通过前序和中序序列或者后序和中序序列来构建这颗二叉树。</p>
<h4 id="前序和中序序列建树">前序和中序序列建树</h4><p>在前序遍历中，遍历二叉树的顺序是根–&gt;左–&gt;右的顺序，而在中序遍历中，遍历顺序是左–&gt;根–&gt;右的顺序。在两者生成的遍历序列中，我们可以很快发现，前序遍历的第一个元素就是该二叉树的根节点，然后再去中序遍历中找到这个元素，因为中序是左–&gt;根–&gt;右的遍历顺序，那么在根节点左侧的字符串就是该根节点的左子树，右侧的字符串就是该节点的右子树。那么对子树，我们有可以从前序遍历中找到相应根节点然后重复做上述步骤，这样就完成了一棵二叉树的建立。由于步骤是一个重复的过程，我们可以使用递归的方式来进行：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree</span><span class="params">(<span class="built_in">string</span> inOrder, <span class="built_in">string</span> preOrder, Node* &amp;t)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> inL, inR, preL, preR;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;                      <span class="comment">//标志变量用于判断是否找到根节点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inOrder.size(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inOrder[i] == preOrder[<span class="number">0</span>]) &#123;    <span class="comment">//查找根节点</span></span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;              	<span class="comment">//在没找到根节点时，把遍历的字符串放入左子树串</span></span><br><span class="line">			inL.push_back(inOrder[i]);</span><br><span class="line">			preL.push_back(preOrder[i + <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;                              	<span class="comment">//找到了后就放入右子树串</span></span><br><span class="line">			inR.push_back(inOrder[i]);</span><br><span class="line">			preR.push_back(preOrder[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;val = preOrder[<span class="number">0</span>];                   <span class="comment">//把当前根值赋给根节点</span></span><br><span class="line">	<span class="keyword">if</span> (inL.size()) &#123;                       <span class="comment">//如果左子树串不为空，那么递归调用，对左子树进行构树</span></span><br><span class="line">		t-&gt;left = <span class="keyword">new</span> Node;</span><br><span class="line">		buildTree(inL, preL, t-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (inR.size()) &#123;                       <span class="comment">//如果右子树串不空，就对右子树构树。</span></span><br><span class="line">		t-&gt;right = <span class="keyword">new</span> Node;</span><br><span class="line">		buildTree(inR, preR, t-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="后序和中序序列建树">后序和中序序列建树</h4><p>后序和中序序列建树的方法大致思路相同，只是在寻找根节点的方法不同，因为后序遍历的顺序是左–&gt;右–&gt;根，所以后序遍历的最后一个元素是根节点，和前序遍历的首元素不同。其他思路可以参考上文，下面是代码的实现:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buildTree2</span><span class="params">(<span class="built_in">string</span> inOrder, <span class="built_in">string</span> postOrder, Node* &amp;t)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">string</span> inL, inR, postL, postR;</span><br><span class="line">	<span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inOrder.size(); i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (inOrder[i] == postOrder[postOrder.size() - <span class="number">1</span>]) &#123;</span><br><span class="line">			flag = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="literal">false</span>) &#123;</span><br><span class="line">			inL.push_back(inOrder[i]);</span><br><span class="line">			postL.push_back(postOrder[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			inR.push_back(inOrder[i]);</span><br><span class="line">			postR.push_back(postOrder[i - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;val = postOrder[postOrder.size() - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">if</span> (inL.size()) &#123;</span><br><span class="line">		t-&gt;left = <span class="keyword">new</span> Node;</span><br><span class="line">		buildTree2(inL, postL, t-&gt;left);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (inR.size()) &#123;</span><br><span class="line">		t-&gt;right = <span class="keyword">new</span> Node;</span><br><span class="line">		buildTree2(inR, postR, t-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[树是一种非常重要的数据结构，树形结构在计算机科学中应用的非常广泛，二叉树是一种特殊的树形结构。本文将讲解数据结构中二叉树的实现及一些在实际应用中的算法实现。]]>
    
    </summary>
    
      <category term="C++" scheme="http://codle.net/tags/C/"/>
    
      <category term="数据结构" scheme="http://codle.net/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="数据结构" scheme="http://codle.net/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用hexo搭建个人博客]]></title>
    <link href="http://codle.net/2015/10/29/how-to-build-hexo/"/>
    <id>http://codle.net/2015/10/29/how-to-build-hexo/</id>
    <published>2015-10-29T07:08:54.000Z</published>
    <updated>2015-10-30T08:19:51.212Z</updated>
    <content type="html"><![CDATA[<h1 id="使用hexo搭建个人博客">使用hexo搭建个人博客</h1><h2 id="前言">前言</h2><p>折腾了两天终于做好了这个博客站，相比于wordpress+虚拟空间的组合，使用Github Page+hexo无疑显得要更加轻便与稳定。<br>下面就来谈一谈是如何在Github上搭建一个hexo博客的。</p>
<h2 id="搭建环境">搭建环境</h2><p>hexo是一个基于node.js的静态博客框架，因此电脑需要安装node.js环境，同时也需要Git软件用于上传博客文件</p>
<ul>
<li><a href="http://nodejs.org" target="_blank" rel="external">Node.js</a></li>
<li><a href="http://git-scm.com/" target="_blank" rel="external">Git</a></li>
</ul>
<h2 id="注册GitHub">注册GitHub</h2><p>访问<a href="http://www.github.com/" target="_blank" rel="external">GitHub</a>官网注册一个账号。</p>
<p>邮箱请确保能收到消息，GitHub上的消息都是通过邮件通知的。</p>
<h2 id="配置和使用GitHub">配置和使用GitHub</h2><p>在注册完GitHub后，进行一些必要的SSH配置，以确保本地Git项目能与远程的Github联系。</p>
<h3 id="检查SSH_Keys">检查SSH Keys</h3><p>首先检查电脑上现有的SSH Keys，打开之前安装的Git Bash，输入：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~/.ssh &#26816;&#26597;&#26412;&#26426;ssh&#23494;&#38053;</span><br></pre></td></tr></table></figure></p>
<p>如果提示: No such file or directory 说明是第一次使用git。</p>
<h3 id="生成新的SSH_Key：">生成新的SSH Key：</h3><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"邮件地址@youremail.com"</span></span><br><span class="line">Generating <span class="keyword">public</span>/<span class="keyword">private</span> rsa <span class="keyword">key</span> pair.</span><br><span class="line">Enter file <span class="keyword">in</span> which <span class="keyword">to</span> save the <span class="keyword">key</span> (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>邮件地址填入你自己的邮箱地址</li>
<li>-C是大写的C，且每个-前面都是有一个空格的</li>
</ul>
<p>然后系统会要求你创建密码：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):<span class="variable">&lt;输入加密串&gt;</span></span><br><span class="line">Enter same passphrase again:<span class="variable">&lt;再次输入加密串&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这个密码在你之后提交项目时使用，如果为空的话在提交项目时可以不输入。这是为了防止别人在你的项目里面提交文件。</p>
<p>注意：输入密码时候不会显示字符或者*，直接输完回车即可。</p>
<p>看到显示一个方框图形就表示成功设置SSH Key了。</p>
<h3 id="添加SSH_Key到GitHub">添加SSH Key到GitHub</h3><p>本机设置SSH Key后，需要添加到GitHub上，已完成SSH链接的设置。</p>
<ol>
<li>用记事本打开本地C:\Users\用户名.ssh\id_rsa.pub文件。这个文件里面内容是刚刚生成的密钥。如果看不到文件，你需要设置显示隐藏文件。ctrl+a复制全部文本。</li>
<li>登陆github。点击右上角头像Settings-&gt;SSH Keys-&gt;Add SSH Key。title可以随便取名，把刚才复制的内容粘贴进Key里面去。</li>
<li>点击Add Key完成设置。</li>
</ol>
<h3 id="测试SSH_Key">测试SSH Key</h3><p>输入下面的命令，看看设置是否成功，请勿改动命令内容:<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh -<span class="constant">T</span> git<span class="variable">@github</span>.com</span><br></pre></td></tr></table></figure></p>
<p>会出现如下内容:<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">The authenticity <span class="keyword">of</span> host <span class="comment">'github.com (207.97.227.239)' can't be established.</span></span><br><span class="line">RSA <span class="keyword">key</span> fingerprint <span class="keyword">is</span> <span class="number">16</span>:<span class="number">27</span>:ac:a5:<span class="number">76</span>:<span class="number">28</span>:<span class="number">2</span>d:<span class="number">36</span>:<span class="number">63</span>:<span class="number">1</span>b:<span class="number">56</span>:<span class="number">4</span>d:eb:df:a6:<span class="number">48.</span></span><br><span class="line">Are you sure you want <span class="keyword">to</span> <span class="keyword">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure></p>
<p>输入yes即可，如果之前设置了SSH Key密码，那么还会要求输入之前的密码<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi user! You've successfully authenticated, <span class="keyword">but</span> GitHub <span class="keyword">does</span> <span class="keyword">not</span> provide shell access.</span><br></pre></td></tr></table></figure></p>
<h3 id="设置用户信息">设置用户信息</h3><p>Git通过用户的名字和邮箱来上传文件，输入下面的代码进行个人信息的设置。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user<span class="class">.name</span> <span class="string">"user"</span><span class="comment">//用户名</span></span><br><span class="line">$ git config --global user<span class="class">.email</span>  <span class="string">"user@gmail.com"</span><span class="comment">//填写自己的邮箱</span></span><br></pre></td></tr></table></figure></p>
<h3 id="SSH_Key配置成功">SSH Key配置成功</h3><p>如果中途出现问题，请按照步骤从头再来一次。</p>
<h2 id="使用GitHub_Page建立博客">使用GitHub Page建立博客</h2><p>GitHub Page是GitHub提供给每个用户的一个功能。可以通过username.github.io的方式进行访问，每个用户名下只能创建一个。</p>
<h3 id="建立仓库">建立仓库</h3><p>登陆GitHub，点击 New Repository 填写项目信息。</p>
<ul>
<li>project name ：username.github.io</li>
<li>description :填写项目描述，可以不写</li>
</ul>
<p>注意：username一定是你的Github名字。</p>
<h2 id="使用hexo">使用hexo</h2><h3 id="安装">安装</h3><p>打开Git Bash，运行下面的命令：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="operator"><span class="keyword">install</span> -<span class="keyword">g</span> hexo</span></span><br></pre></td></tr></table></figure></p>
<p>自己在磁盘中建一个名为hexo的文件夹，在Git Bash中使用cd命令进入hexo文件夹下，运行下面的命令:<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo init</span><br></pre></td></tr></table></figure></p>
<p>就完成了hexo的本地博客安装。</p>
<h3 id="本地浏览">本地浏览</h3><p>我们可以通过下面的命令在本地查看博客：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>hexo s</span><br></pre></td></tr></table></figure></p>
<p>在浏览器输入 localhost:4000 查看。</p>
<h3 id="_config-yml文件">_config.yml文件</h3><p>hexo文件根目录下的_config.yml存储了一些关于博客的基础设置，可以自己查看酌情修改。而theme里面的主题文件对应的_config.yml则是修改主题设置的。</p>
<h3 id="上载自己的博客程序">上载自己的博客程序</h3><p>部署到GitHub前需要配置根目录下的_config.yml文件。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">    <span class="attribute">type</span>: github</span><br><span class="line">    <span class="attribute">repository</span>: git<span class="variable">@github</span>.<span class="attribute">com</span>:username/username.github.com.git</span><br><span class="line">    <span class="attribute">branch</span>: master</span><br></pre></td></tr></table></figure></p>
<p>之后执行下列指令即可完成部署:<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="keyword">g</span></span><br><span class="line">hexo <span class="literal">d</span></span><br></pre></td></tr></table></figure></p>
<p>也可以直接输入：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo <span class="keyword">d</span> -<span class="keyword">g</span></span><br></pre></td></tr></table></figure></p>
<p>即完成了博客的上传。上传完成后就可以通过username.github.io访问你的博客了。</p>
<h2 id="DNS解析">DNS解析</h2><p>如何将博客解析到自己的域名上？可以通过如下设置完成：<br>添加两条A记录:</p>
<ul>
<li>192.30.252.153</li>
<li>192.30.252.154</li>
</ul>
<p>在hexo\sourcex下新建记事本，写上自己的域名，然后改名为CNAME(注意没有后缀名)，然后上载博客。<br>在域名管理中添加CNAME解析，主机记录添加wwww,记录值改为 username.github.io 。</p>
<h2 id="后记">后记</h2><p>感谢各位大大提供的教程:</p>
<ul>
<li><a href="http://cnfeat.com/blog/2014/05/10/how-to-build-a-blog/" target="_blank" rel="external">如何搭建一个独立博客——简明Github Pages与Hexo教程</a></li>
<li><a href="http://yangjian.me/workspace/building-blog-with-hexo/" target="_blank" rel="external">使用hexo搭建博客</a></li>
</ul>
<p>附上需要的链接：</p>
<ul>
<li><a href="https://hexo.io/" target="_blank" rel="external">Hexo官网（是台湾前辈开发的，因此很多文档都带有繁中）</a></li>
<li><a href="https://hexo.io/" target="_blank" rel="external">GitHub Page（如果Ip无法解析了，请及时来看）</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[折腾了两天终于做好了这个博客站，相比于wordpress+虚拟空间的组合，使用Github Page+hexo无疑显得要更加轻便与稳定。下面就来谈一谈是如何在Github上搭建一个hexo博客的。]]>
    
    </summary>
    
      <category term="blog" scheme="http://codle.net/tags/blog/"/>
    
      <category term="hexo" scheme="http://codle.net/tags/hexo/"/>
    
      <category term="博客相关" scheme="http://codle.net/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
</feed>
